<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantiT: quantit::btensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuantiT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A tensor network library for quantum mechanics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>quantit</b></li><li class="navelem"><a class="el" href="classquantit_1_1btensor.html">btensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classquantit_1_1btensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">quantit::btensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>btensor is a type meant to represent block sparse tensor with conservation laws. The conservation law determines which block can or cannot be non-nul. Each block is itself a tensor of the same rank as the overall tensor.  
 <a href="classquantit_1_1btensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="btensor_8h_source.html">btensor.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for quantit::btensor:</div>
<div class="dyncontent">
<div class="center"><img src="classquantit_1_1btensor__coll__graph.png" border="0" usemap="#aquantit_1_1btensor_coll__map" alt="Collaboration graph"/></div>
<map name="aquantit_1_1btensor_coll__map" id="aquantit_1_1btensor_coll__map">
<area shape="rect" title="btensor is a type meant to represent block sparse tensor with conservation laws. The conservation law..." alt="" coords="52,124,177,151"/>
<area shape="rect" href="classproperty.html" title=" " alt="" coords="5,5,224,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquantit_1_1btensor_1_1block__prop__iter.html">block_prop_iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquantit_1_1btensor_1_1block__prop__view.html">block_prop_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquantit_1_1btensor_1_1const__block__prop__iter.html">const_block_prop_iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquantit_1_1btensor_1_1const__block__prop__view.html">const_block_prop_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb10af309cd0aa5b68f995f237f115fb"><td class="memItemLeft" align="right" valign="top"><a id="aeb10af309cd0aa5b68f995f237f115fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_list</b> = std::vector&lt; int64_t &gt;</td></tr>
<tr class="separator:aeb10af309cd0aa5b68f995f237f115fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e43901944555555e9bfee4f0d9ee3f"><td class="memItemLeft" align="right" valign="top"><a id="ad5e43901944555555e9bfee4f0d9ee3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>block_list_t</b> = <a class="el" href="classquantit_1_1flat__map.html">flat_map</a>&lt; index_list, torch::Tensor &gt;</td></tr>
<tr class="separator:ad5e43901944555555e9bfee4f0d9ee3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799bb042f48eff373f4362c44682f39a"><td class="memItemLeft" align="right" valign="top"><a id="a799bb042f48eff373f4362c44682f39a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>init_list_t</b> = std::initializer_list&lt; std::initializer_list&lt; std::tuple&lt; size_t, <a class="el" href="classquantit_1_1any__quantity.html">any_quantity</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:a799bb042f48eff373f4362c44682f39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37483f60431fd313140dc861cb436fa8"><td class="memItemLeft" align="right" valign="top"><a id="a37483f60431fd313140dc861cb436fa8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec_list_t</b> = std::vector&lt; std::vector&lt; std::tuple&lt; size_t, <a class="el" href="classquantit_1_1any__quantity.html">any_quantity</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:a37483f60431fd313140dc861cb436fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb69df3f09347a2c02e972d09db4d300"><td class="memItemLeft" align="right" valign="top"><a id="aeb69df3f09347a2c02e972d09db4d300"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b> = torch::Scalar</td></tr>
<tr class="separator:aeb69df3f09347a2c02e972d09db4d300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9ad2e8d2b3d1631ee17c453e501fe4"><td class="memItemLeft" align="right" valign="top"><a id="a2b9ad2e8d2b3d1631ee17c453e501fe4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>block_qtt_iter</b> = <a class="el" href="structquantit_1_1btensor_1_1block__prop__iter.html">block_prop_iter</a>&lt; <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1cgroup__iterator.html">any_quantity_vector::iterator</a> &gt;</td></tr>
<tr class="separator:a2b9ad2e8d2b3d1631ee17c453e501fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de658368d5bec0fcf660f1493e80779"><td class="memItemLeft" align="right" valign="top"><a id="a6de658368d5bec0fcf660f1493e80779"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_block_qtt_iter</b> = <a class="el" href="structquantit_1_1btensor_1_1const__block__prop__iter.html">const_block_prop_iter</a>&lt; <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1const__cgroup__iterator.html">any_quantity_vector::const_iterator</a>, <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1cgroup__iterator.html">any_quantity_vector::iterator</a> &gt;</td></tr>
<tr class="separator:a6de658368d5bec0fcf660f1493e80779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec964e3f38a2231d64318270f09e9eef"><td class="memItemLeft" align="right" valign="top"><a id="aec964e3f38a2231d64318270f09e9eef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>block_qtt_view</b> = <a class="el" href="structquantit_1_1btensor_1_1block__prop__view.html">block_prop_view</a>&lt; <a class="el" href="structquantit_1_1btensor_1_1block__prop__iter.html">block_qtt_iter</a> &gt;</td></tr>
<tr class="separator:aec964e3f38a2231d64318270f09e9eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04baa4f670f521b48b99b2386d618b2d"><td class="memItemLeft" align="right" valign="top"><a id="a04baa4f670f521b48b99b2386d618b2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_block_qtt_view</b> = <a class="el" href="structquantit_1_1btensor_1_1const__block__prop__view.html">const_block_prop_view</a>&lt; <a class="el" href="structquantit_1_1btensor_1_1const__block__prop__iter.html">const_block_qtt_iter</a>, <a class="el" href="structquantit_1_1btensor_1_1block__prop__iter.html">block_qtt_iter</a> &gt;</td></tr>
<tr class="separator:a04baa4f670f521b48b99b2386d618b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a8bc9c7102251ee3411c774ff625ce"><td class="memItemLeft" align="right" valign="top"><a id="ab9a8bc9c7102251ee3411c774ff625ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>block_size_iter</b> = <a class="el" href="structquantit_1_1btensor_1_1block__prop__iter.html">block_prop_iter</a>&lt; index_list::iterator &gt;</td></tr>
<tr class="separator:ab9a8bc9c7102251ee3411c774ff625ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aeb11429eb42d05d0607f25848050f"><td class="memItemLeft" align="right" valign="top"><a id="a94aeb11429eb42d05d0607f25848050f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_block_size_iter</b> = <a class="el" href="structquantit_1_1btensor_1_1const__block__prop__iter.html">const_block_prop_iter</a>&lt; index_list::const_iterator, index_list::iterator &gt;</td></tr>
<tr class="separator:a94aeb11429eb42d05d0607f25848050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d7a3469e70533a3d74ba7df3475a3d"><td class="memItemLeft" align="right" valign="top"><a id="ab1d7a3469e70533a3d74ba7df3475a3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>block_size_view</b> = <a class="el" href="structquantit_1_1btensor_1_1block__prop__view.html">block_prop_view</a>&lt; <a class="el" href="structquantit_1_1btensor_1_1block__prop__iter.html">block_size_iter</a> &gt;</td></tr>
<tr class="separator:ab1d7a3469e70533a3d74ba7df3475a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85a6e0adca11b45539314974bd4a970"><td class="memItemLeft" align="right" valign="top"><a id="ac85a6e0adca11b45539314974bd4a970"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_block_size_view</b> = <a class="el" href="structquantit_1_1btensor_1_1const__block__prop__view.html">const_block_prop_view</a>&lt; <a class="el" href="structquantit_1_1btensor_1_1const__block__prop__iter.html">const_block_size_iter</a>, <a class="el" href="structquantit_1_1btensor_1_1block__prop__iter.html">block_size_iter</a> &gt;</td></tr>
<tr class="separator:ac85a6e0adca11b45539314974bd4a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b943710b36561f1f76f2bec7e5fa63b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a7b943710b36561f1f76f2bec7e5fa63b">btensor</a> (const vec_list_t &amp;dir_block_size_cqtt, <a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> selection_rule, c10::TensorOptions opt={})</td></tr>
<tr class="memdesc:a7b943710b36561f1f76f2bec7e5fa63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new btensor object.  <a href="classquantit_1_1btensor.html#a7b943710b36561f1f76f2bec7e5fa63b">More...</a><br /></td></tr>
<tr class="separator:a7b943710b36561f1f76f2bec7e5fa63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df7d7b6f5fba87b3b0afeb64cc82cc9"><td class="memItemLeft" align="right" valign="top"><a id="a0df7d7b6f5fba87b3b0afeb64cc82cc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btensor</b> (const vec_list_t &amp;dir_block_size_cqtt, <a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> selection_rule, size_t num_blocks, c10::TensorOptions opt={})</td></tr>
<tr class="separator:a0df7d7b6f5fba87b3b0afeb64cc82cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4b39c3944d26c53ce30924d9d19221"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a7c4b39c3944d26c53ce30924d9d19221">btensor</a> (index_list _sections_by_dim, <a class="el" href="classquantit_1_1any__quantity__vector.html">any_quantity_vector</a> _c_vals, index_list _section_sizes, <a class="el" href="classquantit_1_1any__quantity.html">any_quantity</a> _sel_rule, c10::TensorOptions opt={})</td></tr>
<tr class="memdesc:a7c4b39c3944d26c53ce30924d9d19221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new btensor object from a subset of the raw structure. use carefully.  <a href="classquantit_1_1btensor.html#a7c4b39c3944d26c53ce30924d9d19221">More...</a><br /></td></tr>
<tr class="separator:a7c4b39c3944d26c53ce30924d9d19221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e126c2f39920056eeb828d2dda317c2"><td class="memItemLeft" align="right" valign="top"><a id="a2e126c2f39920056eeb828d2dda317c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btensor</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="separator:a2e126c2f39920056eeb828d2dda317c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781eda489246a61d7e0dec211ebdd8ba"><td class="memItemLeft" align="right" valign="top"><a id="a781eda489246a61d7e0dec211ebdd8ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btensor</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;other)</td></tr>
<tr class="separator:a781eda489246a61d7e0dec211ebdd8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8accb3d7600a33d405d8c82d11c902c"><td class="memItemLeft" align="right" valign="top"><a id="ab8accb3d7600a33d405d8c82d11c902c"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> other)</td></tr>
<tr class="separator:ab8accb3d7600a33d405d8c82d11c902c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4b09d43d375bcacfde1e9d3828c9f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a9c4b09d43d375bcacfde1e9d3828c9f4">btensor</a> (size_t _rank, <a class="el" href="classquantit_1_1flat__map.html">block_list_t</a> _blocks, index_list _sections_by_dims, index_list _sections_sizes, <a class="el" href="classquantit_1_1any__quantity__vector.html">any_quantity_vector</a> _c_vals, <a class="el" href="classquantit_1_1any__quantity.html">any_quantity</a> _sel_rule, c10::TensorOptions opt={})</td></tr>
<tr class="memdesc:a9c4b09d43d375bcacfde1e9d3828c9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new btensor object. construct from raw structure elements. Avoid using this constructor if you can.  <a href="classquantit_1_1btensor.html#a9c4b09d43d375bcacfde1e9d3828c9f4">More...</a><br /></td></tr>
<tr class="separator:a9c4b09d43d375bcacfde1e9d3828c9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210be19c2e6965f45a5d028a27edb2df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a210be19c2e6965f45a5d028a27edb2df">sizes</a> () const</td></tr>
<tr class="memdesc:a210be19c2e6965f45a5d028a27edb2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the list of the sizes along each dimensions of the tensor  <a href="classquantit_1_1btensor.html#a210be19c2e6965f45a5d028a27edb2df">More...</a><br /></td></tr>
<tr class="separator:a210be19c2e6965f45a5d028a27edb2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c490238e0022b585dc430b13ec7dd1"><td class="memItemLeft" align="right" valign="top">btensor::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a01c490238e0022b585dc430b13ec7dd1">item</a> () const</td></tr>
<tr class="memdesc:a01c490238e0022b585dc430b13ec7dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the tensor contain a single element, return a scalar object.  <a href="classquantit_1_1btensor.html#a01c490238e0022b585dc430b13ec7dd1">More...</a><br /></td></tr>
<tr class="separator:a01c490238e0022b585dc430b13ec7dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7831359050b455e8bf4ead7bf205a1ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a7831359050b455e8bf4ead7bf205a1ae">block_increment</a> (btensor::index_list &amp;block_index) const</td></tr>
<tr class="memdesc:a7831359050b455e8bf4ead7bf205a1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment a block index for this tensor  <a href="classquantit_1_1btensor.html#a7831359050b455e8bf4ead7bf205a1ae">More...</a><br /></td></tr>
<tr class="separator:a7831359050b455e8bf4ead7bf205a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebd3d5bdf055354b82254067e13e5c9"><td class="memItemLeft" align="right" valign="top"><a id="a3ebd3d5bdf055354b82254067e13e5c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;)</td></tr>
<tr class="separator:a3ebd3d5bdf055354b82254067e13e5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b489b6f960e7846245baf2aaa7d66a0"><td class="memItemLeft" align="right" valign="top"><a id="a0b489b6f960e7846245baf2aaa7d66a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>block_conservation_rule_test</b> (index_list block_index) const</td></tr>
<tr class="separator:a0b489b6f960e7846245baf2aaa7d66a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4ad1dc15c534551a0e716f779f6347"><td class="memItemLeft" align="right" valign="top"><a id="a1d4ad1dc15c534551a0e716f779f6347"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>section_size</b> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>, size_t section) const</td></tr>
<tr class="separator:a1d4ad1dc15c534551a0e716f779f6347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294fa5ce9cebda7d6e4dfe94bc2c0384"><td class="memItemLeft" align="right" valign="top"><a id="a294fa5ce9cebda7d6e4dfe94bc2c0384"></a>
std::tuple&lt; index_list::const_iterator, index_list::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>section_sizes</b> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>) const</td></tr>
<tr class="separator:a294fa5ce9cebda7d6e4dfe94bc2c0384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8011c285612e00a24b08f15fad6b3ea7"><td class="memItemLeft" align="right" valign="top"><a id="a8011c285612e00a24b08f15fad6b3ea7"></a>
std::tuple&lt; <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1const__cgroup__iterator.html">any_quantity_vector::const_iterator</a>, <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1const__cgroup__iterator.html">any_quantity_vector::const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>section_cqtts</b> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>) const</td></tr>
<tr class="separator:a8011c285612e00a24b08f15fad6b3ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60ecb2f76a04f7c8aa26650065b4919"><td class="memItemLeft" align="right" valign="top"><a id="ae60ecb2f76a04f7c8aa26650065b4919"></a>
std::tuple&lt; index_list::const_iterator, index_list::const_iterator, <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1const__cgroup__iterator.html">any_quantity_vector::const_iterator</a>, <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1const__cgroup__iterator.html">any_quantity_vector::const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>section_sizes_cqtts</b> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>) const</td></tr>
<tr class="separator:ae60ecb2f76a04f7c8aa26650065b4919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735a54314939812d6a072b99e08e4f41"><td class="memItemLeft" align="right" valign="top"><a id="a735a54314939812d6a072b99e08e4f41"></a>
<a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td><td class="memItemRight" valign="bottom"><b>section_conserved_qtt</b> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>, size_t section) const</td></tr>
<tr class="separator:a735a54314939812d6a072b99e08e4f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72c9562dfdb8f20eadec23949fd57fd"><td class="memItemLeft" align="right" valign="top"><a id="aa72c9562dfdb8f20eadec23949fd57fd"></a>
<a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td><td class="memItemRight" valign="bottom"><b>element_conserved_qtt</b> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>, size_t element) const</td></tr>
<tr class="separator:aa72c9562dfdb8f20eadec23949fd57fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bbbb38aaf2a2ce2bfb72a64daa94d3"><td class="memItemLeft" align="right" valign="top"><a id="a06bbbb38aaf2a2ce2bfb72a64daa94d3"></a>
std::tuple&lt; <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1const__cgroup__iterator.html">any_quantity_vector::const_iterator</a>, <a class="el" href="structquantit_1_1vQuantiT__iterator_1_1const__cgroup__iterator.html">any_quantity_vector::const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>section_conserved_qtt_range</b> (size_t <a class="el" href="classquantit_1_1btensor.html#ab59f73f7c6380e0bd8ca60e576d4b8d2">index</a>) const</td></tr>
<tr class="separator:a06bbbb38aaf2a2ce2bfb72a64daa94d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361df233fa9fdcd0b30f00f4a96d5bfa"><td class="memItemLeft" align="right" valign="top"><a id="a361df233fa9fdcd0b30f00f4a96d5bfa"></a>
std::tuple&lt; size_t, <a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>section_size_cqtt</b> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>, size_t section) const</td></tr>
<tr class="separator:a361df233fa9fdcd0b30f00f4a96d5bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab310947ff381e337d498cc343766a13c"><td class="memItemLeft" align="right" valign="top">torch::Tensor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ab310947ff381e337d498cc343766a13c">block_at</a> (const index_list &amp;)</td></tr>
<tr class="memdesc:ab310947ff381e337d498cc343766a13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the block at the block index given in argument.  <a href="classquantit_1_1btensor.html#ab310947ff381e337d498cc343766a13c">More...</a><br /></td></tr>
<tr class="separator:ab310947ff381e337d498cc343766a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c88f784e4188dcb1f96e10a280bec8"><td class="memItemLeft" align="right" valign="top">torch::Tensor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a04c88f784e4188dcb1f96e10a280bec8">block</a> (const index_list &amp;)</td></tr>
<tr class="memdesc:a04c88f784e4188dcb1f96e10a280bec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the block at the index given in argument. Allocate space for the block if necessary.  <a href="classquantit_1_1btensor.html#a04c88f784e4188dcb1f96e10a280bec8">More...</a><br /></td></tr>
<tr class="separator:a04c88f784e4188dcb1f96e10a280bec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18334e24f0068037814d8b060c60a0fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classquantit_1_1flat__map.html">block_list_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a18334e24f0068037814d8b060c60a0fc">blocks</a> () const</td></tr>
<tr class="memdesc:a18334e24f0068037814d8b060c60a0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reference to the raw block list.  <a href="classquantit_1_1btensor.html#a18334e24f0068037814d8b060c60a0fc">More...</a><br /></td></tr>
<tr class="separator:a18334e24f0068037814d8b060c60a0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1720ff8aa74853ae8bb00909342b6776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structquantit_1_1btensor_1_1const__block__prop__view.html">const_block_qtt_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a1720ff8aa74853ae8bb00909342b6776">block_quantities</a> (const index_list &amp;block_index) const</td></tr>
<tr class="memdesc:a1720ff8aa74853ae8bb00909342b6776"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain a view on the conserved quantities of each indices of a block with the block index given in argument  <a href="classquantit_1_1btensor.html#a1720ff8aa74853ae8bb00909342b6776">More...</a><br /></td></tr>
<tr class="separator:a1720ff8aa74853ae8bb00909342b6776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18efb9612ab0b9c34f438f0197abc502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structquantit_1_1btensor_1_1const__block__prop__view.html">const_block_size_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a18efb9612ab0b9c34f438f0197abc502">block_sizes</a> (const index_list &amp;block_index) const</td></tr>
<tr class="memdesc:a18efb9612ab0b9c34f438f0197abc502"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain a view on the size of the block.  <a href="classquantit_1_1btensor.html#a18efb9612ab0b9c34f438f0197abc502">More...</a><br /></td></tr>
<tr class="separator:a18efb9612ab0b9c34f438f0197abc502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399cee30857b6b711c46817bbc0a9c56"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a> () const</td></tr>
<tr class="memdesc:a399cee30857b6b711c46817bbc0a9c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rank of the tensor.  <a href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">More...</a><br /></td></tr>
<tr class="separator:a399cee30857b6b711c46817bbc0a9c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88cd6bb654832133a7dfbefa8f629c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#af88cd6bb654832133a7dfbefa8f629c1">section_number</a> (size_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>) const</td></tr>
<tr class="memdesc:af88cd6bb654832133a7dfbefa8f629c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of sections in a given dimension  <a href="classquantit_1_1btensor.html#af88cd6bb654832133a7dfbefa8f629c1">More...</a><br /></td></tr>
<tr class="separator:af88cd6bb654832133a7dfbefa8f629c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ce624f7923057fe83535f2a72b87d"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ab35ce624f7923057fe83535f2a72b87d">section_numbers</a> () const</td></tr>
<tr class="memdesc:ab35ce624f7923057fe83535f2a72b87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of section for all the dimensions, in order.  <a href="classquantit_1_1btensor.html#ab35ce624f7923057fe83535f2a72b87d">More...</a><br /></td></tr>
<tr class="separator:ab35ce624f7923057fe83535f2a72b87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa2904aa349cfaff3cb451676bfd1e7"><td class="memItemLeft" align="right" valign="top"><a id="abfa2904aa349cfaff3cb451676bfd1e7"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_cvals</b> () const</td></tr>
<tr class="separator:abfa2904aa349cfaff3cb451676bfd1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee959f8823a1ccb165e6ddeced75b0f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#aee959f8823a1ccb165e6ddeced75b0f6">shape_from</a> (const std::vector&lt; int64_t &gt; &amp;dims) const</td></tr>
<tr class="memdesc:aee959f8823a1ccb165e6ddeced75b0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an empty tensor from selected dimensions of this. Minimum necessary set of feature for tensor network reshape.  <a href="classquantit_1_1btensor.html#aee959f8823a1ccb165e6ddeced75b0f6">More...</a><br /></td></tr>
<tr class="separator:aee959f8823a1ccb165e6ddeced75b0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8619fb2e99352fa12aa8525ea3ecdcf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a8619fb2e99352fa12aa8525ea3ecdcf0">basic_create_view</a> (const std::vector&lt; int64_t &gt; &amp;dims, bool preserve_rank=false)</td></tr>
<tr class="memdesc:a8619fb2e99352fa12aa8525ea3ecdcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a view object on this tensor. Minimum necessary set of feature for tensor network reshape.  <a href="classquantit_1_1btensor.html#a8619fb2e99352fa12aa8525ea3ecdcf0">More...</a><br /></td></tr>
<tr class="separator:a8619fb2e99352fa12aa8525ea3ecdcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78bdfc2bf9c771f09ee0841c2455e02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ad78bdfc2bf9c771f09ee0841c2455e02">basic_index_put_</a> (const std::vector&lt; int64_t &gt; &amp;dims, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;value)</td></tr>
<tr class="memdesc:ad78bdfc2bf9c771f09ee0841c2455e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">make all the the conserved value and the conservation rule the neutral element of the group. works only on empty tensors.  <a href="classquantit_1_1btensor.html#ad78bdfc2bf9c771f09ee0841c2455e02">More...</a><br /></td></tr>
<tr class="separator:ad78bdfc2bf9c771f09ee0841c2455e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb1f1daac073010f9ce461eeeb2953a"><td class="memItemLeft" align="right" valign="top"><a id="abfb1f1daac073010f9ce461eeeb2953a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>basic_index_put_</b> (const std::vector&lt; int64_t &gt; &amp;dims, const torch::Tensor &amp;value)</td></tr>
<tr class="separator:abfb1f1daac073010f9ce461eeeb2953a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f6a9b00c7da20c43dca330f396e486"><td class="memItemLeft" align="right" valign="top"><a id="ad0f6a9b00c7da20c43dca330f396e486"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>neutral_shape</b> () const</td></tr>
<tr class="separator:ad0f6a9b00c7da20c43dca330f396e486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5ce2bf6e0c189de1475db903fcef87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a6c5ce2bf6e0c189de1475db903fcef87">neutral_shape_</a> ()</td></tr>
<tr class="separator:a6c5ce2bf6e0c189de1475db903fcef87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a016599b6c1ba4a98111075081acda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ad0a016599b6c1ba4a98111075081acda">tensor_product_shape</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="memdesc:ad0a016599b6c1ba4a98111075081acda"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the shape of the tensor product of this with the other tensor. store the shape information in an empty btensor  <a href="classquantit_1_1btensor.html#ad0a016599b6c1ba4a98111075081acda">More...</a><br /></td></tr>
<tr class="separator:ad0a016599b6c1ba4a98111075081acda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f73f7c6380e0bd8ca60e576d4b8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ab59f73f7c6380e0bd8ca60e576d4b8d2">index</a> (torch::ArrayRef&lt; torch::indexing::TensorIndex &gt; indices) const</td></tr>
<tr class="memdesc:ab59f73f7c6380e0bd8ca60e576d4b8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a view on the block tensor.  <a href="classquantit_1_1btensor.html#ab59f73f7c6380e0bd8ca60e576d4b8d2">More...</a><br /></td></tr>
<tr class="separator:ab59f73f7c6380e0bd8ca60e576d4b8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa058a2117553c629ce362eb711945e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#aa058a2117553c629ce362eb711945e58">index</a> (std::initializer_list&lt; torch::indexing::TensorIndex &gt; indices) const</td></tr>
<tr class="memdesc:aa058a2117553c629ce362eb711945e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a view on the block tensor.  <a href="classquantit_1_1btensor.html#aa058a2117553c629ce362eb711945e58">More...</a><br /></td></tr>
<tr class="separator:aa058a2117553c629ce362eb711945e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee26adff8b22f7c20d85706b0deda4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a8ee26adff8b22f7c20d85706b0deda4a">index_put_</a> (torch::ArrayRef&lt; torch::indexing::TensorIndex &gt; indices, const torch::Tensor &amp;rhs)</td></tr>
<tr class="memdesc:a8ee26adff8b22f7c20d85706b0deda4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements insertion operator, for basic torch tensor.  <a href="classquantit_1_1btensor.html#a8ee26adff8b22f7c20d85706b0deda4a">More...</a><br /></td></tr>
<tr class="separator:a8ee26adff8b22f7c20d85706b0deda4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a73b856d0a4da81209ed45b483bba4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a0a73b856d0a4da81209ed45b483bba4a">index_put_</a> (torch::ArrayRef&lt; torch::indexing::TensorIndex &gt; indices, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0a73b856d0a4da81209ed45b483bba4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements insertion operator, for block tensor.  <a href="classquantit_1_1btensor.html#a0a73b856d0a4da81209ed45b483bba4a">More...</a><br /></td></tr>
<tr class="separator:a0a73b856d0a4da81209ed45b483bba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7fed837898e36e46e003819b5183ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a9f7fed837898e36e46e003819b5183ca">index_put_</a> (torch::ArrayRef&lt; torch::indexing::TensorIndex &gt; indices, const Scalar &amp;v)</td></tr>
<tr class="memdesc:a9f7fed837898e36e46e003819b5183ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements insertion operator, for scalars.  <a href="classquantit_1_1btensor.html#a9f7fed837898e36e46e003819b5183ca">More...</a><br /></td></tr>
<tr class="separator:a9f7fed837898e36e46e003819b5183ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc6df002361366fd2a92b8719114ebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a6fc6df002361366fd2a92b8719114ebf">index_put_</a> (std::initializer_list&lt; torch::indexing::TensorIndex &gt; indices, const torch::Tensor &amp;rhs)</td></tr>
<tr class="memdesc:a6fc6df002361366fd2a92b8719114ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements insertion operator, for basic torch tensor.  <a href="classquantit_1_1btensor.html#a6fc6df002361366fd2a92b8719114ebf">More...</a><br /></td></tr>
<tr class="separator:a6fc6df002361366fd2a92b8719114ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf801ccfc47e2cea549de96560345924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#abf801ccfc47e2cea549de96560345924">index_put_</a> (std::initializer_list&lt; torch::indexing::TensorIndex &gt; indices, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;rhs)</td></tr>
<tr class="memdesc:abf801ccfc47e2cea549de96560345924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements insertion operator, for block tensor.  <a href="classquantit_1_1btensor.html#abf801ccfc47e2cea549de96560345924">More...</a><br /></td></tr>
<tr class="separator:abf801ccfc47e2cea549de96560345924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aa8e2f2b22575d4927170457d44a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a89aa8e2f2b22575d4927170457d44a30">index_put_</a> (std::initializer_list&lt; torch::indexing::TensorIndex &gt; indices, const Scalar &amp;v)</td></tr>
<tr class="memdesc:a89aa8e2f2b22575d4927170457d44a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements insertion operator, for scalars.  <a href="classquantit_1_1btensor.html#a89aa8e2f2b22575d4927170457d44a30">More...</a><br /></td></tr>
<tr class="separator:a89aa8e2f2b22575d4927170457d44a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00094f5a1ebec2e8ce64be0e46c94ebe"><td class="memItemLeft" align="right" valign="top"><a id="a00094f5a1ebec2e8ce64be0e46c94ebe"></a>
block_list_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a00094f5a1ebec2e8ce64be0e46c94ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eb039a3e9c204c80735ac4e0f74142"><td class="memItemLeft" align="right" valign="top"><a id="a01eb039a3e9c204c80735ac4e0f74142"></a>
block_list_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:a01eb039a3e9c204c80735ac4e0f74142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8899443c274e6db7ca917836f861589"><td class="memItemLeft" align="right" valign="top"><a id="ad8899443c274e6db7ca917836f861589"></a>
block_list_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="separator:ad8899443c274e6db7ca917836f861589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440442cbdd7adeff498dd085416e5c16"><td class="memItemLeft" align="right" valign="top"><a id="a440442cbdd7adeff498dd085416e5c16"></a>
block_list_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const</td></tr>
<tr class="separator:a440442cbdd7adeff498dd085416e5c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af81f39b41b1c84109617d5c4ec0972"><td class="memItemLeft" align="right" valign="top"><a id="a1af81f39b41b1c84109617d5c4ec0972"></a>
block_list_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a1af81f39b41b1c84109617d5c4ec0972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f16613c11ecfd2f15732ec5b607a877"><td class="memItemLeft" align="right" valign="top"><a id="a7f16613c11ecfd2f15732ec5b607a877"></a>
block_list_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a7f16613c11ecfd2f15732ec5b607a877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a22df7a1f01cdb4ccd465a03d4ca808"><td class="memItemLeft" align="right" valign="top"><a id="a6a22df7a1f01cdb4ccd465a03d4ca808"></a>
block_list_t::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:a6a22df7a1f01cdb4ccd465a03d4ca808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcba131e1100c9098ed28212a9a12e8a"><td class="memItemLeft" align="right" valign="top"><a id="adcba131e1100c9098ed28212a9a12e8a"></a>
block_list_t::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:adcba131e1100c9098ed28212a9a12e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62792eef34b2dded3fbba91cd45996b2"><td class="memItemLeft" align="right" valign="top"><a id="a62792eef34b2dded3fbba91cd45996b2"></a>
block_list_t::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="separator:a62792eef34b2dded3fbba91cd45996b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0ba29335c083d7961c4529fc602c2f"><td class="memItemLeft" align="right" valign="top"><a id="abd0ba29335c083d7961c4529fc602c2f"></a>
block_list_t::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const</td></tr>
<tr class="separator:abd0ba29335c083d7961c4529fc602c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d94c40cbe874876ae68f77f2c79e348"><td class="memItemLeft" align="right" valign="top"><a id="a7d94c40cbe874876ae68f77f2c79e348"></a>
block_list_t::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const</td></tr>
<tr class="separator:a7d94c40cbe874876ae68f77f2c79e348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5637f6bda9a4e667b129405552356c3c"><td class="memItemLeft" align="right" valign="top"><a id="a5637f6bda9a4e667b129405552356c3c"></a>
block_list_t::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const</td></tr>
<tr class="separator:a5637f6bda9a4e667b129405552356c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a97b9d52b04fe14bf7bb5a55a810382"><td class="memItemLeft" align="right" valign="top">torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a6a97b9d52b04fe14bf7bb5a55a810382">to_dense</a> () const</td></tr>
<tr class="memdesc:a6a97b9d52b04fe14bf7bb5a55a810382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the block tensor to a regular torch tensor.  <a href="classquantit_1_1btensor.html#a6a97b9d52b04fe14bf7bb5a55a810382">More...</a><br /></td></tr>
<tr class="separator:a6a97b9d52b04fe14bf7bb5a55a810382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96b62005aa71662e4c7be762595a91a"><td class="memItemLeft" align="right" valign="top"><a id="af96b62005aa71662e4c7be762595a91a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, Scalar alpha=1) const</td></tr>
<tr class="separator:af96b62005aa71662e4c7be762595a91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8578bce0213f9a97133fe029d166379d"><td class="memItemLeft" align="right" valign="top"><a id="a8578bce0213f9a97133fe029d166379d"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;other, Scalar alpha=1) const</td></tr>
<tr class="separator:a8578bce0213f9a97133fe029d166379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9526260fef259dd49605138f3769716f"><td class="memItemLeft" align="right" valign="top"><a id="a9526260fef259dd49605138f3769716f"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>add_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, Scalar alpha=1)</td></tr>
<tr class="separator:a9526260fef259dd49605138f3769716f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597fc1701d2ebd5c7d4e1c793eaa6f0a"><td class="memItemLeft" align="right" valign="top"><a id="a597fc1701d2ebd5c7d4e1c793eaa6f0a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>add_</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;other, Scalar alpha=1)</td></tr>
<tr class="separator:a597fc1701d2ebd5c7d4e1c793eaa6f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61453fe8c5919bb7b9d8c44bdec010b8"><td class="memItemLeft" align="right" valign="top"><a id="a61453fe8c5919bb7b9d8c44bdec010b8"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (Scalar other, Scalar alpha=1) const</td></tr>
<tr class="separator:a61453fe8c5919bb7b9d8c44bdec010b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ab2c98b40f8d211e7b29667a07db6d"><td class="memItemLeft" align="right" valign="top"><a id="a14ab2c98b40f8d211e7b29667a07db6d"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>add_</b> (Scalar other, Scalar alpha=1)</td></tr>
<tr class="separator:a14ab2c98b40f8d211e7b29667a07db6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109c38d9761e577b74558b47d79d4578"><td class="memItemLeft" align="right" valign="top"><a id="a109c38d9761e577b74558b47d79d4578"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (Scalar other)</td></tr>
<tr class="separator:a109c38d9761e577b74558b47d79d4578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39e1beeba982b25c0f685303e027e25"><td class="memItemLeft" align="right" valign="top"><a id="ae39e1beeba982b25c0f685303e027e25"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (Scalar other)</td></tr>
<tr class="separator:ae39e1beeba982b25c0f685303e027e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0734b0facdc54c239ff1b64e87171d3"><td class="memItemLeft" align="right" valign="top"><a id="ae0734b0facdc54c239ff1b64e87171d3"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="separator:ae0734b0facdc54c239ff1b64e87171d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d421493a2bef0fb493e62e5618a618"><td class="memItemLeft" align="right" valign="top"><a id="a08d421493a2bef0fb493e62e5618a618"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;other)</td></tr>
<tr class="separator:a08d421493a2bef0fb493e62e5618a618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dadd7696686ea3f3650421c11943fd0"><td class="memItemLeft" align="right" valign="top"><a id="a7dadd7696686ea3f3650421c11943fd0"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="separator:a7dadd7696686ea3f3650421c11943fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572bea2379c409bb44200f0878b97e58"><td class="memItemLeft" align="right" valign="top"><a id="a572bea2379c409bb44200f0878b97e58"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;other)</td></tr>
<tr class="separator:a572bea2379c409bb44200f0878b97e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb649cdc2c3dccc52bc7bdb238fb48"><td class="memItemLeft" align="right" valign="top"><a id="a0fbb649cdc2c3dccc52bc7bdb238fb48"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addmv</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;vec, Scalar beta=1, Scalar alpha=1) const</td></tr>
<tr class="separator:a0fbb649cdc2c3dccc52bc7bdb238fb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c237aa88404ca69b436595059891d2"><td class="memItemLeft" align="right" valign="top"><a id="ae1c237aa88404ca69b436595059891d2"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addmv</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;vec, Scalar beta=1)</td></tr>
<tr class="separator:ae1c237aa88404ca69b436595059891d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a1fabfd0e6a768b43eff04cf3f9a21"><td class="memItemLeft" align="right" valign="top"><a id="a85a1fabfd0e6a768b43eff04cf3f9a21"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addmm</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat2, Scalar beta=1, Scalar alpha=1) const</td></tr>
<tr class="separator:a85a1fabfd0e6a768b43eff04cf3f9a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f44d187d4667fe0c81560b78484437"><td class="memItemLeft" align="right" valign="top"><a id="ac6f44d187d4667fe0c81560b78484437"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addmm_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat2, Scalar beta=1, Scalar alpha=1)</td></tr>
<tr class="separator:ac6f44d187d4667fe0c81560b78484437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934f94b32a52932fbf814752da785079"><td class="memItemLeft" align="right" valign="top"><a id="a934f94b32a52932fbf814752da785079"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addbmm</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat2, Scalar beta=1, Scalar alpha=1) const</td></tr>
<tr class="separator:a934f94b32a52932fbf814752da785079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5c505c6648216266a2b66aac9f180d"><td class="memItemLeft" align="right" valign="top"><a id="a4a5c505c6648216266a2b66aac9f180d"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addbmm_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat2, Scalar beta=1, Scalar alpha=1)</td></tr>
<tr class="separator:a4a5c505c6648216266a2b66aac9f180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e41d89ccffb5e64d76018b541063f9b"><td class="memItemLeft" align="right" valign="top"><a id="a6e41d89ccffb5e64d76018b541063f9b"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addcdiv_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor2, Scalar beta=1)</td></tr>
<tr class="separator:a6e41d89ccffb5e64d76018b541063f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fd2e36a8a8e998c826a4f3deb702b9"><td class="memItemLeft" align="right" valign="top"><a id="a98fd2e36a8a8e998c826a4f3deb702b9"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addcdiv</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor2, Scalar beta=1)</td></tr>
<tr class="separator:a98fd2e36a8a8e998c826a4f3deb702b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf4d3a76553ccfc58b4225dadd8edc2"><td class="memItemLeft" align="right" valign="top"><a id="a2cf4d3a76553ccfc58b4225dadd8edc2"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addcmul_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor2, Scalar beta=1)</td></tr>
<tr class="separator:a2cf4d3a76553ccfc58b4225dadd8edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1b6997c86e54a0c155c835dc926e17"><td class="memItemLeft" align="right" valign="top"><a id="aed1b6997c86e54a0c155c835dc926e17"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addcmul</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor2, Scalar beta=1)</td></tr>
<tr class="separator:aed1b6997c86e54a0c155c835dc926e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cea3afb4bf3aabde1c67496ef9417df"><td class="memItemLeft" align="right" valign="top"><a id="a7cea3afb4bf3aabde1c67496ef9417df"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>baddbmm</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;bathc1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;batch2, Scalar beta=1, Scalar alpha=1) const</td></tr>
<tr class="separator:a7cea3afb4bf3aabde1c67496ef9417df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7027c2e58d1e8e37b4b3fd037d9e3bee"><td class="memItemLeft" align="right" valign="top"><a id="a7027c2e58d1e8e37b4b3fd037d9e3bee"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>baddbmm_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;bathc1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;batch2, Scalar beta=1, Scalar alpha=1)</td></tr>
<tr class="separator:a7027c2e58d1e8e37b4b3fd037d9e3bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268117f541ac845d75c1b1acd100332b"><td class="memItemLeft" align="right" valign="top"><a id="a268117f541ac845d75c1b1acd100332b"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bmm</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mat) const</td></tr>
<tr class="separator:a268117f541ac845d75c1b1acd100332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41654c3bd38f3b1b33b84e3506582ab"><td class="memItemLeft" align="right" valign="top"><a id="af41654c3bd38f3b1b33b84e3506582ab"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:af41654c3bd38f3b1b33b84e3506582ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43817292c24dfe72c39c9e0603579de0"><td class="memItemLeft" align="right" valign="top"><a id="a43817292c24dfe72c39c9e0603579de0"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vdot</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:a43817292c24dfe72c39c9e0603579de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad212ce7cbdf200de9a551d7001f83b74"><td class="memItemLeft" align="right" valign="top"><a id="ad212ce7cbdf200de9a551d7001f83b74"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kron</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:ad212ce7cbdf200de9a551d7001f83b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8698e15b3f765e2a86fe5c73bd7b03c"><td class="memItemLeft" align="right" valign="top"><a id="ae8698e15b3f765e2a86fe5c73bd7b03c"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matmul</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:ae8698e15b3f765e2a86fe5c73bd7b03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebeb61ac88feba87faf1c79d6fdce752"><td class="memItemLeft" align="right" valign="top"><a id="aebeb61ac88feba87faf1c79d6fdce752"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mm</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:aebeb61ac88feba87faf1c79d6fdce752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a1677cb63da7bbf239d4e1d7afc09e"><td class="memItemLeft" align="right" valign="top"><a id="aa4a1677cb63da7bbf239d4e1d7afc09e"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b> () const</td></tr>
<tr class="separator:aa4a1677cb63da7bbf239d4e1d7afc09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d6bc11752aad4ea4ef2a6e378cfc0"><td class="memItemLeft" align="right" valign="top"><a id="a0e7d6bc11752aad4ea4ef2a6e378cfc0"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>t</b> () const</td></tr>
<tr class="separator:a0e7d6bc11752aad4ea4ef2a6e378cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2fb6168468677f515607b5fc0fd1ac"><td class="memItemLeft" align="right" valign="top"><a id="a3c2fb6168468677f515607b5fc0fd1ac"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>t_</b> ()</td></tr>
<tr class="separator:a3c2fb6168468677f515607b5fc0fd1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100bc35dd4606a1d980569ccf56585d2"><td class="memItemLeft" align="right" valign="top"><a id="a100bc35dd4606a1d980569ccf56585d2"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> () const</td></tr>
<tr class="separator:a100bc35dd4606a1d980569ccf56585d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d5621994a0b7ece0059ebb593d9734"><td class="memItemLeft" align="right" valign="top"><a id="a21d5621994a0b7ece0059ebb593d9734"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt_</b> ()</td></tr>
<tr class="separator:a21d5621994a0b7ece0059ebb593d9734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af695d8c1b5d38554476920f3f851ee47"><td class="memItemLeft" align="right" valign="top"><a id="af695d8c1b5d38554476920f3f851ee47"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> () const</td></tr>
<tr class="separator:af695d8c1b5d38554476920f3f851ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cc572eb5a962bcb4be2c1535ba0659"><td class="memItemLeft" align="right" valign="top"><a id="ae9cc572eb5a962bcb4be2c1535ba0659"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>abs_</b> ()</td></tr>
<tr class="separator:ae9cc572eb5a962bcb4be2c1535ba0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edf85382bbee55870229540c4912f1d"><td class="memItemLeft" align="right" valign="top"><a id="a0edf85382bbee55870229540c4912f1d"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (btensor::Scalar exponent) const</td></tr>
<tr class="separator:a0edf85382bbee55870229540c4912f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23779d7148f1df5e9938eb0b3bf087e6"><td class="memItemLeft" align="right" valign="top"><a id="a23779d7148f1df5e9938eb0b3bf087e6"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pow_</b> (btensor::Scalar exponent)</td></tr>
<tr class="separator:a23779d7148f1df5e9938eb0b3bf087e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dae84454200f432ddfd492fde24b72"><td class="memItemLeft" align="right" valign="top"><a id="a50dae84454200f432ddfd492fde24b72"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;exponent) const</td></tr>
<tr class="separator:a50dae84454200f432ddfd492fde24b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52141be90fab8e1e2448b3e2aec7666"><td class="memItemLeft" align="right" valign="top"><a id="ad52141be90fab8e1e2448b3e2aec7666"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pow_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;exponent)</td></tr>
<tr class="separator:ad52141be90fab8e1e2448b3e2aec7666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47de70372c7a3f14c9d93adb9080b7f"><td class="memItemLeft" align="right" valign="top"><a id="ad47de70372c7a3f14c9d93adb9080b7f"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ge</b> (btensor::Scalar other) const</td></tr>
<tr class="separator:ad47de70372c7a3f14c9d93adb9080b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b55ae642f17719ef8a2306e32b12784"><td class="memItemLeft" align="right" valign="top"><a id="a2b55ae642f17719ef8a2306e32b12784"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ge</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:a2b55ae642f17719ef8a2306e32b12784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea176d77f4c6f36028686deac4504598"><td class="memItemLeft" align="right" valign="top"><a id="aea176d77f4c6f36028686deac4504598"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>le</b> (btensor::Scalar other) const</td></tr>
<tr class="separator:aea176d77f4c6f36028686deac4504598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab478cbf5313025c9bf41f0ff54461551"><td class="memItemLeft" align="right" valign="top"><a id="ab478cbf5313025c9bf41f0ff54461551"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>le</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:ab478cbf5313025c9bf41f0ff54461551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93efef1358386621a55b873ff07d9a6"><td class="memItemLeft" align="right" valign="top"><a id="af93efef1358386621a55b873ff07d9a6"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>less</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:af93efef1358386621a55b873ff07d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a198ec575e269590c4c64cee195811"><td class="memItemLeft" align="right" valign="top"><a id="a65a198ec575e269590c4c64cee195811"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>less</b> (btensor::Scalar other) const</td></tr>
<tr class="separator:a65a198ec575e269590c4c64cee195811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f813e6608623a45693c1c382228c74e"><td class="memItemLeft" align="right" valign="top"><a id="a0f813e6608623a45693c1c382228c74e"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>greater</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:a0f813e6608623a45693c1c382228c74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb9b50353bc493fc4d3821b316edc65"><td class="memItemLeft" align="right" valign="top"><a id="a4fb9b50353bc493fc4d3821b316edc65"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>greater</b> (btensor::Scalar other) const</td></tr>
<tr class="separator:a4fb9b50353bc493fc4d3821b316edc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bc5383bef6944c61e02a14a9a91518"><td class="memItemLeft" align="right" valign="top"><a id="a98bc5383bef6944c61e02a14a9a91518"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eq</b> (btensor::Scalar other) const</td></tr>
<tr class="separator:a98bc5383bef6944c61e02a14a9a91518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34e73f2bdad1b54ec94c0a3b36a59a8"><td class="memItemLeft" align="right" valign="top"><a id="ac34e73f2bdad1b54ec94c0a3b36a59a8"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eq</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:ac34e73f2bdad1b54ec94c0a3b36a59a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc44085de7c7513c38b3f3ae9e43a1c"><td class="memItemLeft" align="right" valign="top"><a id="aecc44085de7c7513c38b3f3ae9e43a1c"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>not_equal</b> (btensor::Scalar other) const</td></tr>
<tr class="separator:aecc44085de7c7513c38b3f3ae9e43a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2c790e8f5322426b50a0c4d82d1cbf"><td class="memItemLeft" align="right" valign="top"><a id="a2c2c790e8f5322426b50a0c4d82d1cbf"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>not_equal</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:a2c2c790e8f5322426b50a0c4d82d1cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aff6124cf79f4cb30bd60e6854d4144"><td class="memItemLeft" align="right" valign="top"><a id="a7aff6124cf79f4cb30bd60e6854d4144"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>div</b> (btensor::Scalar) const</td></tr>
<tr class="separator:a7aff6124cf79f4cb30bd60e6854d4144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2171441c703a4fe016e25f6720c191b"><td class="memItemLeft" align="right" valign="top"><a id="aa2171441c703a4fe016e25f6720c191b"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>div_</b> (btensor::Scalar)</td></tr>
<tr class="separator:aa2171441c703a4fe016e25f6720c191b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5086e4795d6315c37e2f2cfe46fceca9"><td class="memItemLeft" align="right" valign="top"><a id="a5086e4795d6315c37e2f2cfe46fceca9"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>div</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:a5086e4795d6315c37e2f2cfe46fceca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c224fcf93e375c7ce9e4bc814c75d"><td class="memItemLeft" align="right" valign="top"><a id="a463c224fcf93e375c7ce9e4bc814c75d"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>div_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="separator:a463c224fcf93e375c7ce9e4bc814c75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25492fd0cf70bd04a15152b2828ff84a"><td class="memItemLeft" align="right" valign="top"><a id="a25492fd0cf70bd04a15152b2828ff84a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (btensor::Scalar val)</td></tr>
<tr class="separator:a25492fd0cf70bd04a15152b2828ff84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4773f1a5435c9f67462c9d00bb69cd"><td class="memItemLeft" align="right" valign="top"><a id="a6f4773f1a5435c9f67462c9d00bb69cd"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="separator:a6f4773f1a5435c9f67462c9d00bb69cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9257048ffbc8a78ea6825c979b8c9f6c"><td class="memItemLeft" align="right" valign="top"><a id="a9257048ffbc8a78ea6825c979b8c9f6c"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (btensor::Scalar val)</td></tr>
<tr class="separator:a9257048ffbc8a78ea6825c979b8c9f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7602827a205d1054a078242c3fde3b70"><td class="memItemLeft" align="right" valign="top"><a id="a7602827a205d1054a078242c3fde3b70"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="separator:a7602827a205d1054a078242c3fde3b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c927b4b96f0df440eb15d371d60326c"><td class="memItemLeft" align="right" valign="top"><a id="a1c927b4b96f0df440eb15d371d60326c"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> ()</td></tr>
<tr class="separator:a1c927b4b96f0df440eb15d371d60326c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88360f21d921bc565957aa94c292e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ac88360f21d921bc565957aa94c292e3e">mul_</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="memdesc:ac88360f21d921bc565957aa94c292e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place element wise product, with broadcasting on size 1 dimensions.  <a href="classquantit_1_1btensor.html#ac88360f21d921bc565957aa94c292e3e">More...</a><br /></td></tr>
<tr class="separator:ac88360f21d921bc565957aa94c292e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a0ad6ab7a223e665a04f2a4a74be54"><td class="memItemLeft" align="right" valign="top"><a id="a53a0ad6ab7a223e665a04f2a4a74be54"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mul</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:a53a0ad6ab7a223e665a04f2a4a74be54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9329bdb7db6827c606f518afdf723bfc"><td class="memItemLeft" align="right" valign="top"><a id="a9329bdb7db6827c606f518afdf723bfc"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mul</b> (Scalar other) const</td></tr>
<tr class="separator:a9329bdb7db6827c606f518afdf723bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d4aeb5542d3b146adc8c7f618bd5d4"><td class="memItemLeft" align="right" valign="top"><a id="ab4d4aeb5542d3b146adc8c7f618bd5d4"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>mul_</b> (Scalar other)</td></tr>
<tr class="separator:ab4d4aeb5542d3b146adc8c7f618bd5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648ff1a8b48695e2220c67c163d2b87a"><td class="memItemLeft" align="right" valign="top"><a id="a648ff1a8b48695e2220c67c163d2b87a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="separator:a648ff1a8b48695e2220c67c163d2b87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbcd853d7db4e7f879281cacd927d24"><td class="memItemLeft" align="right" valign="top"><a id="aecbcd853d7db4e7f879281cacd927d24"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>multiply_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other)</td></tr>
<tr class="separator:aecbcd853d7db4e7f879281cacd927d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5759ec5ee73a725f919e21c9ad5893da"><td class="memItemLeft" align="right" valign="top"><a id="a5759ec5ee73a725f919e21c9ad5893da"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>multiply</b> (Scalar other) const</td></tr>
<tr class="separator:a5759ec5ee73a725f919e21c9ad5893da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf2c3bced0851d2ffa2963b8f8f868a"><td class="memItemLeft" align="right" valign="top"><a id="acdf2c3bced0851d2ffa2963b8f8f868a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>multiply_</b> (Scalar other)</td></tr>
<tr class="separator:acdf2c3bced0851d2ffa2963b8f8f868a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef107bf98b7a14ff7b18ee6ab74138fe"><td class="memItemLeft" align="right" valign="top"><a id="aef107bf98b7a14ff7b18ee6ab74138fe"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mv</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;vec) const</td></tr>
<tr class="separator:aef107bf98b7a14ff7b18ee6ab74138fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1f8e920e86f933c19ce6c3326104ef"><td class="memItemLeft" align="right" valign="top"><a id="a0c1f8e920e86f933c19ce6c3326104ef"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>permute</b> (torch::IntArrayRef) const</td></tr>
<tr class="separator:a0c1f8e920e86f933c19ce6c3326104ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1177240b65cf9ae984ac05bd5d6453"><td class="memItemLeft" align="right" valign="top"><a id="a6e1177240b65cf9ae984ac05bd5d6453"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>permute_</b> (torch::IntArrayRef)</td></tr>
<tr class="separator:a6e1177240b65cf9ae984ac05bd5d6453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e6084e8589ae5ae4236cb35c27f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a444e6084e8589ae5ae4236cb35c27f01">reshape</a> (torch::IntArrayRef index_group) const</td></tr>
<tr class="memdesc:a444e6084e8589ae5ae4236cb35c27f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the btensor into a btensor of a lower rank.  <a href="classquantit_1_1btensor.html#a444e6084e8589ae5ae4236cb35c27f01">More...</a><br /></td></tr>
<tr class="separator:a444e6084e8589ae5ae4236cb35c27f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0f704cd6343d24b4a42031e2e22bc5"><td class="memTemplParams" colspan="2">template&lt;reshape_mode mode = reshape_mode::dims_only&gt; </td></tr>
<tr class="memitem:a5c0f704cd6343d24b4a42031e2e22bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a5c0f704cd6343d24b4a42031e2e22bc5">reshape_as</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other) const</td></tr>
<tr class="memdesc:a5c0f704cd6343d24b4a42031e2e22bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">reshape the tensor into the shape of the supplied tensor.  <a href="classquantit_1_1btensor.html#a5c0f704cd6343d24b4a42031e2e22bc5">More...</a><br /></td></tr>
<tr class="separator:a5c0f704cd6343d24b4a42031e2e22bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391e6d73f73bc486c0f080e6cd8ab7a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a391e6d73f73bc486c0f080e6cd8ab7a8">reshape</a> (std::initializer_list&lt; int64_t &gt; a)</td></tr>
<tr class="memdesc:a391e6d73f73bc486c0f080e6cd8ab7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the btensor into a btensor of a lower rank.  <a href="classquantit_1_1btensor.html#a391e6d73f73bc486c0f080e6cd8ab7a8">More...</a><br /></td></tr>
<tr class="separator:a391e6d73f73bc486c0f080e6cd8ab7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6176a831cc6ebf1769453bbd38846e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a6176a831cc6ebf1769453bbd38846e3f">transpose</a> (int64_t dim0, int64_t dim1) const</td></tr>
<tr class="memdesc:a6176a831cc6ebf1769453bbd38846e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchange the order of two indices.  <a href="classquantit_1_1btensor.html#a6176a831cc6ebf1769453bbd38846e3f">More...</a><br /></td></tr>
<tr class="separator:a6176a831cc6ebf1769453bbd38846e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dcc4e14de14d0077d36d74455e5273"><td class="memItemLeft" align="right" valign="top"><a id="a68dcc4e14de14d0077d36d74455e5273"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>transpose_</b> (int64_t dim0, int64_t dim1)</td></tr>
<tr class="separator:a68dcc4e14de14d0077d36d74455e5273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401c2c270d7f5f3863215461c914e602"><td class="memItemLeft" align="right" valign="top"><a id="a401c2c270d7f5f3863215461c914e602"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sub</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, Scalar alpha=1) const</td></tr>
<tr class="separator:a401c2c270d7f5f3863215461c914e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8a3cb85f0c1835e35be8e9fda06691"><td class="memItemLeft" align="right" valign="top"><a id="a8a8a3cb85f0c1835e35be8e9fda06691"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sub_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, Scalar alpha=1)</td></tr>
<tr class="separator:a8a8a3cb85f0c1835e35be8e9fda06691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8cefd06bd67dfd951c7a94401887b8"><td class="memItemLeft" align="right" valign="top"><a id="adb8cefd06bd67dfd951c7a94401887b8"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sub</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;other, Scalar alpha=1) const</td></tr>
<tr class="separator:adb8cefd06bd67dfd951c7a94401887b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d131c891643d88c0528c9065d37de5b"><td class="memItemLeft" align="right" valign="top"><a id="a4d131c891643d88c0528c9065d37de5b"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sub_</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;other, Scalar alpha=1)</td></tr>
<tr class="separator:a4d131c891643d88c0528c9065d37de5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac466be1e461dcb032af2f3ab98493448"><td class="memItemLeft" align="right" valign="top"><a id="ac466be1e461dcb032af2f3ab98493448"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sub</b> (Scalar other, Scalar alpha=1) const</td></tr>
<tr class="separator:ac466be1e461dcb032af2f3ab98493448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a49aa0e6dd17e12ad2d19286499acaa"><td class="memItemLeft" align="right" valign="top"><a id="a1a49aa0e6dd17e12ad2d19286499acaa"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sub_</b> (Scalar other, Scalar alpha=1)</td></tr>
<tr class="separator:a1a49aa0e6dd17e12ad2d19286499acaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cd93fed91f19af47c00bb34ff38191"><td class="memItemLeft" align="right" valign="top"><a id="a87cd93fed91f19af47c00bb34ff38191"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>subtract</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, Scalar alpha=1) const</td></tr>
<tr class="separator:a87cd93fed91f19af47c00bb34ff38191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2d3056bf180fc794a0d5ecfee4105e"><td class="memItemLeft" align="right" valign="top"><a id="a3a2d3056bf180fc794a0d5ecfee4105e"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>subtract_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, Scalar alpha=1)</td></tr>
<tr class="separator:a3a2d3056bf180fc794a0d5ecfee4105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2304fb10f081161f3bfe8ceabd60b5"><td class="memItemLeft" align="right" valign="top"><a id="a3a2304fb10f081161f3bfe8ceabd60b5"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>subtract</b> (Scalar other, Scalar alpha=1) const</td></tr>
<tr class="separator:a3a2304fb10f081161f3bfe8ceabd60b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307aac4131fc15a55d2badd728eaf5c5"><td class="memItemLeft" align="right" valign="top"><a id="a307aac4131fc15a55d2badd728eaf5c5"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>subtract_</b> (Scalar other, Scalar alpha=1)</td></tr>
<tr class="separator:a307aac4131fc15a55d2badd728eaf5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c0666de033a5a36b7cb44a25ba264a"><td class="memItemLeft" align="right" valign="top"><a id="aa4c0666de033a5a36b7cb44a25ba264a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tensordot</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, torch::IntArrayRef dim_self, torch::IntArrayRef dims_other) const</td></tr>
<tr class="separator:aa4c0666de033a5a36b7cb44a25ba264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156b81939db01a79de8ce940526a8d6a"><td class="memItemLeft" align="right" valign="top"><a id="a156b81939db01a79de8ce940526a8d6a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tensorgdot</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mul1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mul2, torch::IntArrayRef dims1, torch::IntArrayRef dims2, Scalar beta=1, Scalar alpha=1) const</td></tr>
<tr class="separator:a156b81939db01a79de8ce940526a8d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b6cdd46a57cdf88154a7f037d19517"><td class="memItemLeft" align="right" valign="top"><a id="af1b6cdd46a57cdf88154a7f037d19517"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>tensorgdot_</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mul1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;mul2, torch::IntArrayRef dims1, torch::IntArrayRef dims2, Scalar beta=1, Scalar alpha=1)</td></tr>
<tr class="separator:af1b6cdd46a57cdf88154a7f037d19517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2702c03eed0b59e2aeddb841c192fa9"><td class="memItemLeft" align="right" valign="top"><a id="aa2702c03eed0b59e2aeddb841c192fa9"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>squeeze</b> () const</td></tr>
<tr class="separator:aa2702c03eed0b59e2aeddb841c192fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cea434fb7a2ad8f76d9f963b6d7e1a"><td class="memItemLeft" align="right" valign="top"><a id="a34cea434fb7a2ad8f76d9f963b6d7e1a"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>squeeze</b> (int64_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>) const</td></tr>
<tr class="separator:a34cea434fb7a2ad8f76d9f963b6d7e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aec6d672f962905833cd3dd78f99463"><td class="memItemLeft" align="right" valign="top"><a id="a5aec6d672f962905833cd3dd78f99463"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>squeeze_</b> (int64_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>)</td></tr>
<tr class="separator:a5aec6d672f962905833cd3dd78f99463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ee2b72c7e9770a451578470a3006ae"><td class="memItemLeft" align="right" valign="top"><a id="ad8ee2b72c7e9770a451578470a3006ae"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>squeeze_</b> ()</td></tr>
<tr class="separator:ad8ee2b72c7e9770a451578470a3006ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ab07624a9c6e63cd48e89eea35fc7"><td class="memItemLeft" align="right" valign="top"><a id="a300ab07624a9c6e63cd48e89eea35fc7"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isnan</b> () const</td></tr>
<tr class="separator:a300ab07624a9c6e63cd48e89eea35fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2252bc461a496d4006b6cf7c92c6ea63"><td class="memItemLeft" align="right" valign="top"><a id="a2252bc461a496d4006b6cf7c92c6ea63"></a>
torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><b>any</b> () const</td></tr>
<tr class="separator:a2252bc461a496d4006b6cf7c92c6ea63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa573174ccaa323bf64189e3a88eb1a14"><td class="memItemLeft" align="right" valign="top"><a id="aa573174ccaa323bf64189e3a88eb1a14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>anynan</b> () const</td></tr>
<tr class="separator:aa573174ccaa323bf64189e3a88eb1a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecbb590915372481349263bcc60cfd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a7ecbb590915372481349263bcc60cfd8">conj</a> () const</td></tr>
<tr class="memdesc:a7ecbb590915372481349263bcc60cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the complex conjugate of this tensor and inverse the conserved quantities  <a href="classquantit_1_1btensor.html#a7ecbb590915372481349263bcc60cfd8">More...</a><br /></td></tr>
<tr class="separator:a7ecbb590915372481349263bcc60cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902003e818128aef05e5e6a39ac77501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a902003e818128aef05e5e6a39ac77501">conj_only</a> () const</td></tr>
<tr class="memdesc:a902003e818128aef05e5e6a39ac77501"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the complex conjugate of this tensor  <a href="classquantit_1_1btensor.html#a902003e818128aef05e5e6a39ac77501">More...</a><br /></td></tr>
<tr class="separator:a902003e818128aef05e5e6a39ac77501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1742f2450d18a58b0508799e9d48c469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a1742f2450d18a58b0508799e9d48c469">inverse_cvals</a> () const</td></tr>
<tr class="memdesc:a1742f2450d18a58b0508799e9d48c469"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new tensor with its section rule and all its conserved quantities inversed.  <a href="classquantit_1_1btensor.html#a1742f2450d18a58b0508799e9d48c469">More...</a><br /></td></tr>
<tr class="separator:a1742f2450d18a58b0508799e9d48c469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5960100f9b13fb48702b30644283d9a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a5960100f9b13fb48702b30644283d9a4">inverse_cvals_</a> ()</td></tr>
<tr class="memdesc:a5960100f9b13fb48702b30644283d9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse the selection rule and all the conserved quantities of this btensor.  <a href="classquantit_1_1btensor.html#a5960100f9b13fb48702b30644283d9a4">More...</a><br /></td></tr>
<tr class="separator:a5960100f9b13fb48702b30644283d9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef10a4a7f737d8d45fb4e457440bf7de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#aef10a4a7f737d8d45fb4e457440bf7de">cval_shift</a> (<a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> shift, int64_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>) const</td></tr>
<tr class="memdesc:aef10a4a7f737d8d45fb4e457440bf7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the conserved quantities of one dimension of the tensor, applies the opposite shift to the conservation rule.  <a href="classquantit_1_1btensor.html#aef10a4a7f737d8d45fb4e457440bf7de">More...</a><br /></td></tr>
<tr class="separator:aef10a4a7f737d8d45fb4e457440bf7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037f8cc269cc93d75d84a95fbb0b16a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a037f8cc269cc93d75d84a95fbb0b16a2">cval_shift_</a> (<a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> shift, int64_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>)</td></tr>
<tr class="memdesc:a037f8cc269cc93d75d84a95fbb0b16a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the conserved quantities of one dimension of the tensor, applies the opposite shift to the conservation rule.  <a href="classquantit_1_1btensor.html#a037f8cc269cc93d75d84a95fbb0b16a2">More...</a><br /></td></tr>
<tr class="separator:a037f8cc269cc93d75d84a95fbb0b16a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6934183b8e07a5548b6af93fa6d30676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a6934183b8e07a5548b6af93fa6d30676">non_conserving_cval_shift_</a> (<a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> shift, int64_t <a class="el" href="classquantit_1_1btensor.html#a399cee30857b6b711c46817bbc0a9c56">dim</a>)</td></tr>
<tr class="memdesc:a6934183b8e07a5548b6af93fa6d30676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the conserved quantities of one dimension of the tensor without regards for the conservation laws.  <a href="classquantit_1_1btensor.html#a6934183b8e07a5548b6af93fa6d30676">More...</a><br /></td></tr>
<tr class="separator:a6934183b8e07a5548b6af93fa6d30676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e02d410e3e3c2f32903b352917877a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#af4e02d410e3e3c2f32903b352917877a">shift_selection_rule_</a> (<a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> shift)</td></tr>
<tr class="memdesc:af4e02d410e3e3c2f32903b352917877a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the selection rule by the value of shift. Can only be done on empty tensors .  <a href="classquantit_1_1btensor.html#af4e02d410e3e3c2f32903b352917877a">More...</a><br /></td></tr>
<tr class="separator:af4e02d410e3e3c2f32903b352917877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f9b62db4386110f2b9db59615638f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#af1f9b62db4386110f2b9db59615638f1">reserve_space_</a> (size_t N)</td></tr>
<tr class="memdesc:af1f9b62db4386110f2b9db59615638f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space in the block list.  <a href="classquantit_1_1btensor.html#af1f9b62db4386110f2b9db59615638f1">More...</a><br /></td></tr>
<tr class="separator:af1f9b62db4386110f2b9db59615638f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22340d87671cb9256b2ddd62a3d1419"><td class="memItemLeft" align="right" valign="top"><a id="af22340d87671cb9256b2ddd62a3d1419"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve_space_</b> (btensor_size)</td></tr>
<tr class="separator:af22340d87671cb9256b2ddd62a3d1419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb0fa9598edbcca7bd461e828efcae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a8eb0fa9598edbcca7bd461e828efcae9">set_selection_rule_</a> (<a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> value)</td></tr>
<tr class="memdesc:a8eb0fa9598edbcca7bd461e828efcae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the selection rule of the block tensor.  <a href="classquantit_1_1btensor.html#a8eb0fa9598edbcca7bd461e828efcae9">More...</a><br /></td></tr>
<tr class="separator:a8eb0fa9598edbcca7bd461e828efcae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9938ca873fca45a633e65c789586a3dc"><td class="memItemLeft" align="right" valign="top"><a id="a9938ca873fca45a633e65c789586a3dc"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>neutral_selection_rule_</b> ()</td></tr>
<tr class="separator:a9938ca873fca45a633e65c789586a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6491831f28313cb7bfb8898d382c6cfc"><td class="memItemLeft" align="right" valign="top"><a id="a6491831f28313cb7bfb8898d382c6cfc"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>neutral_selection_rule</b> () const</td></tr>
<tr class="separator:a6491831f28313cb7bfb8898d382c6cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df6cbc84f2195e0e9c31bb46ddf8c7f"><td class="memItemLeft" align="right" valign="top"><a id="a4df6cbc84f2195e0e9c31bb46ddf8c7f"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (const torch::TensorOptions &amp;options={}, bool non_blocking=false, bool copy=false, c10::optional&lt; c10::MemoryFormat &gt; memory_format=c10::nullopt) const</td></tr>
<tr class="separator:a4df6cbc84f2195e0e9c31bb46ddf8c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dad57c873818fa9617f58522a1a9a8"><td class="memItemLeft" align="right" valign="top"><a id="ad7dad57c873818fa9617f58522a1a9a8"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;other, bool non_blocking=false, bool copy=false, c10::optional&lt; c10::MemoryFormat &gt; memory_format=c10::nullopt) const</td></tr>
<tr class="separator:ad7dad57c873818fa9617f58522a1a9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c16637e525d988d89da32becf61b75"><td class="memItemLeft" align="right" valign="top"><a id="a45c16637e525d988d89da32becf61b75"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (torch::Device device, torch::ScalarType dtype, bool non_blocking=false, bool copy=false, c10::optional&lt; c10::MemoryFormat &gt; memory_format=c10::nullopt) const</td></tr>
<tr class="separator:a45c16637e525d988d89da32becf61b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66093d2d85010a3398aa2785e7cf7e4"><td class="memItemLeft" align="right" valign="top"><a id="ab66093d2d85010a3398aa2785e7cf7e4"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (torch::ScalarType dtype, bool non_blocking=false, bool copy=false, c10::optional&lt; c10::MemoryFormat &gt; memory_format=c10::nullopt) const</td></tr>
<tr class="separator:ab66093d2d85010a3398aa2785e7cf7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2807c9fa229dd591b20d3b66eee7cd"><td class="memItemLeft" align="right" valign="top"><a id="a6e2807c9fa229dd591b20d3b66eee7cd"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (caffe2::TypeMeta type_meta, bool non_blocking=false, bool copy=false, c10::optional&lt; c10::MemoryFormat &gt; memory_format=c10::nullopt) const</td></tr>
<tr class="separator:a6e2807c9fa229dd591b20d3b66eee7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f19565b73f40fd31973702e6862f46"><td class="memItemLeft" align="right" valign="top"><a id="ad8f19565b73f40fd31973702e6862f46"></a>
<a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (const torch::Tensor &amp;other, bool non_blocking=false, bool copy=false, c10::optional&lt; c10::MemoryFormat &gt; memory_format=c10::nullopt) const</td></tr>
<tr class="separator:ad8f19565b73f40fd31973702e6862f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd5ce01b1230d8623719b3671337a8c"><td class="memItemLeft" align="right" valign="top"><a id="a0bd5ce01b1230d8623719b3671337a8c"></a>
c10::TensorOptions&#160;</td><td class="memItemRight" valign="bottom"><b>options</b> () const</td></tr>
<tr class="separator:a0bd5ce01b1230d8623719b3671337a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a02622134dc835f3a333bac282a1cb"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; index_list, index_list &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ad9a02622134dc835f3a333bac282a1cb">element_index_decompose</a> (const index_list &amp;element_index) const</td></tr>
<tr class="memdesc:ad9a02622134dc835f3a333bac282a1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">split an index adressing an element within the full tensor into a block index, block-element index pair.  <a href="classquantit_1_1btensor.html#ad9a02622134dc835f3a333bac282a1cb">More...</a><br /></td></tr>
<tr class="separator:ad9a02622134dc835f3a333bac282a1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aac31d2c7bd9c3900b27542ce17fbe274"><td class="memItemLeft" align="right" valign="top"><a id="aac31d2c7bd9c3900b27542ce17fbe274"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>btensor_compute_max_size</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;btens, size_t max=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:aac31d2c7bd9c3900b27542ce17fbe274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917ea0d16b970cf832504a502cbf1289"><td class="memItemLeft" align="right" valign="top"><a id="a917ea0d16b970cf832504a502cbf1289"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>add_tensor_check</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;a, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;b)</td></tr>
<tr class="separator:a917ea0d16b970cf832504a502cbf1289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba4b107e02154ce231380c1bb844766"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#aaba4b107e02154ce231380c1bb844766">check_tensor</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;)</td></tr>
<tr class="memdesc:aaba4b107e02154ce231380c1bb844766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the tensor is correct.  <a href="classquantit_1_1btensor.html#aaba4b107e02154ce231380c1bb844766">More...</a><br /></td></tr>
<tr class="separator:aaba4b107e02154ce231380c1bb844766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8897e8e51c880654c5d467b2b0a8bc"><td class="memItemLeft" align="right" valign="top"><a id="a5d8897e8e51c880654c5d467b2b0a8bc"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a5d8897e8e51c880654c5d467b2b0a8bc">throw_bad_tensor</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;)</td></tr>
<tr class="memdesc:a5d8897e8e51c880654c5d467b2b0a8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">throw an error in any situation where check_tensor return a non-empty string <br /></td></tr>
<tr class="separator:a5d8897e8e51c880654c5d467b2b0a8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6638386777d0b8bed4efa38635f44d0a"><td class="memTemplParams" colspan="2"><a id="a6638386777d0b8bed4efa38635f44d0a"></a>
template&lt;bool Throws = false&gt; </td></tr>
<tr class="memitem:a6638386777d0b8bed4efa38635f44d0a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_product_compat</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;in1, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;in2, torch::IntArrayRef dims1, torch::IntArrayRef dims2) noexcept(!Throws)</td></tr>
<tr class="separator:a6638386777d0b8bed4efa38635f44d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584d58aef82ff1994c454d5644142e5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; torch::indexing::TensorIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a0584d58aef82ff1994c454d5644142e5">full_slice</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tensor, const btensor::index_list &amp;<a class="el" href="classquantit_1_1btensor.html#a04c88f784e4188dcb1f96e10a280bec8">block</a>)</td></tr>
<tr class="memdesc:a0584d58aef82ff1994c454d5644142e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the slices associated with a block in a full tensor with the same shape.  <a href="classquantit_1_1btensor.html#a0584d58aef82ff1994c454d5644142e5">More...</a><br /></td></tr>
<tr class="separator:a0584d58aef82ff1994c454d5644142e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb787c67f9a0c677d9182eb4e92ece6"><td class="memItemLeft" align="right" valign="top"><a id="acbb787c67f9a0c677d9182eb4e92ece6"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_same_shape</b> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;a, const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;b)</td></tr>
<tr class="separator:acbb787c67f9a0c677d9182eb4e92ece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a30cc2f016d81c4956955aeff74f9683e"><td class="memItemLeft" align="right" valign="top"><a id="a30cc2f016d81c4956955aeff74f9683e"></a>
<a class="el" href="classproperty.html">property</a>&lt; <a class="el" href="classquantit_1_1any__quantity.html">any_quantity</a>, <a class="el" href="classquantit_1_1btensor.html">btensor</a>, <a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>selection_rule</b></td></tr>
<tr class="separator:a30cc2f016d81c4956955aeff74f9683e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8abcac097679ea55af2d1d69154fc3cd"><td class="memItemLeft" align="right" valign="top"><a id="a8abcac097679ea55af2d1d69154fc3cd"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>fmt::formatter&lt; quantit::btensor &gt;</b></td></tr>
<tr class="separator:a8abcac097679ea55af2d1d69154fc3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5093c86ab4783ee74c199212372e1a8d"><td class="memItemLeft" align="right" valign="top"><a id="a5093c86ab4783ee74c199212372e1a8d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>mul_helpers</b></td></tr>
<tr class="separator:a5093c86ab4783ee74c199212372e1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0ba61994d2725dc6cc24c47deefa7f"><td class="memTemplParams" colspan="2"><a id="aba0ba61994d2725dc6cc24c47deefa7f"></a>
template&lt;class... BTENS&gt; </td></tr>
<tr class="memitem:aba0ba61994d2725dc6cc24c47deefa7f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classquantit_1_1btensor.html">btensor</a>, std::tuple&lt; BTENS... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>truncate_impl</b> (<a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&amp;d, std::tuple&lt; BTENS... &gt; &amp;&amp;unitaries, size_t max, size_t min, btensor::Scalar tol, btensor::Scalar pow)</td></tr>
<tr class="separator:aba0ba61994d2725dc6cc24c47deefa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d65b7567711e3a99727df6139563d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#a17d65b7567711e3a99727df6139563d8">sparse_zeros_like</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;tens, c10::TensorOptions opt)</td></tr>
<tr class="memdesc:a17d65b7567711e3a99727df6139563d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an empty (no allocatred blocks) btensor with the same shape and selection rule as the imput tensor  <a href="classquantit_1_1btensor.html#a17d65b7567711e3a99727df6139563d8">More...</a><br /></td></tr>
<tr class="separator:a17d65b7567711e3a99727df6139563d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56cbb1dbc7e3b803e8e44aca0a02c45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquantit_1_1btensor.html#ac56cbb1dbc7e3b803e8e44aca0a02c45">eye_like</a> (const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;shape, c10::TensorOptions opt)</td></tr>
<tr class="memdesc:ac56cbb1dbc7e3b803e8e44aca0a02c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a matrix with the identity matrix for every permited block on the diagonnal.  <a href="classquantit_1_1btensor.html#ac56cbb1dbc7e3b803e8e44aca0a02c45">More...</a><br /></td></tr>
<tr class="separator:ac56cbb1dbc7e3b803e8e44aca0a02c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>btensor is a type meant to represent block sparse tensor with conservation laws. The conservation law determines which block can or cannot be non-nul. Each block is itself a tensor of the same rank as the overall tensor. </p>
<p>Each dimensions of the tensor are separated in sections with independent sizes, each of those section has an associated conserved quantity. The blocks are formed by the intersection of those section. The only block that can contain non-zero values are those the satisfy the selection rule: the sum over the dimension of the conserved quantity must equal a specififed value (the selection rule).</p>
<p>exemple with a rank 2 tensor (matrix) of the inner structure of this type: </p><pre class="fragment">             S0,0  S0,1  S0,2  S0,3
            
                                  
        S1,0(0,0) (0,1) (0,2)(0,3)
                                  
           
                                  
        S1,1(1,0) (1,1) (1,2)(1,3)
                                  
           
                                  
        S1,2(2,0) (2,1) (2,2)(2,3)
                                  
            
</pre><p> In the preceding exemple, the rows are separated in 4 sections, and the columns in 3 sections. This make up to 12 blocks, that we label by section. Let's consider that the conserved quantity is simply an integer under the addition,that the column sections [-2,-1,1], the row sections have the conserved quantity [1,2,3,-1] and the selection rule is 0. In that case, only the blocks [(1,0),(0,1),(2,3)] can be non-zero. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b943710b36561f1f76f2bec7e5fa63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b943710b36561f1f76f2bec7e5fa63b">&#9670;&nbsp;</a></span>btensor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quantit::btensor::btensor </td>
          <td>(</td>
          <td class="paramtype">const vec_list_t &amp;&#160;</td>
          <td class="paramname"><em>dir_block_size_cqtt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td>
          <td class="paramname"><em>selection_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c10::TensorOptions&#160;</td>
          <td class="paramname"><em>opt</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new btensor object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_block_size_cqtt</td><td>a nested list of pair of section size and conserved quantities. The number of element in the first is level is the rank of the tensor. The number of elements in the second level is the number of section for that dimension of the tensor </td></tr>
    <tr><td class="paramname">selection_rule</td><td>determine which blocks are allowed to be non-zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c4b39c3944d26c53ce30924d9d19221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4b39c3944d26c53ce30924d9d19221">&#9670;&nbsp;</a></span>btensor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quantit::btensor::btensor </td>
          <td>(</td>
          <td class="paramtype">index_list&#160;</td>
          <td class="paramname"><em>_sections_by_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classquantit_1_1any__quantity__vector.html">any_quantity_vector</a>&#160;</td>
          <td class="paramname"><em>_c_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_list&#160;</td>
          <td class="paramname"><em>_section_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classquantit_1_1any__quantity.html">any_quantity</a>&#160;</td>
          <td class="paramname"><em>_sel_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c10::TensorOptions&#160;</td>
          <td class="paramname"><em>opt</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new btensor object from a subset of the raw structure. use carefully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_sections_by_dim</td><td></td></tr>
    <tr><td class="paramname">_c_vals</td><td></td></tr>
    <tr><td class="paramname">_section_sizes</td><td></td></tr>
    <tr><td class="paramname">_sel_rule</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c4b09d43d375bcacfde1e9d3828c9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4b09d43d375bcacfde1e9d3828c9f4">&#9670;&nbsp;</a></span>btensor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quantit::btensor::btensor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classquantit_1_1flat__map.html">block_list_t</a>&#160;</td>
          <td class="paramname"><em>_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_list&#160;</td>
          <td class="paramname"><em>_sections_by_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_list&#160;</td>
          <td class="paramname"><em>_sections_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classquantit_1_1any__quantity__vector.html">any_quantity_vector</a>&#160;</td>
          <td class="paramname"><em>_c_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classquantit_1_1any__quantity.html">any_quantity</a>&#160;</td>
          <td class="paramname"><em>_sel_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c10::TensorOptions&#160;</td>
          <td class="paramname"><em>opt</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new btensor object. construct from raw structure elements. Avoid using this constructor if you can. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_rank</td><td>: the number of dimension of the tensor </td></tr>
    <tr><td class="paramname">_blocks</td><td>: list of pair&lt;position,sub-tensor&gt;, the position is stored in a block index </td></tr>
    <tr><td class="paramname">_sections_by_dims</td><td>: number of section for each dimension of the tensor </td></tr>
    <tr><td class="paramname">_section_sizes</td><td>: number of element for each section of each dimension </td></tr>
    <tr><td class="paramname">_c_vals</td><td>: conserved quantity associated to each of the section in each of the dimension </td></tr>
    <tr><td class="paramname">_sel_rule</td><td>: overall selection rule, the sum over the dimension of the conserved quantities of a given block must equal this value for a block to be allowed to differ from zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8619fb2e99352fa12aa8525ea3ecdcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8619fb2e99352fa12aa8525ea3ecdcf0">&#9670;&nbsp;</a></span>basic_create_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::basic_create_view </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_rank</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a view object on this tensor. Minimum necessary set of feature for tensor network reshape. </p>
<p>Basic version of index, it can only discard whole dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>List of dimensions, put -1 to keep the dimension, specify the index to keep otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; </dd></dl>

</div>
</div>
<a id="ad78bdfc2bf9c771f09ee0841c2455e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78bdfc2bf9c771f09ee0841c2455e02">&#9670;&nbsp;</a></span>basic_index_put_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::basic_index_put_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make all the the conserved value and the conservation rule the neutral element of the group. works only on empty tensors. </p>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; </dd></dl>

</div>
</div>
<a id="a04c88f784e4188dcb1f96e10a280bec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c88f784e4188dcb1f96e10a280bec8">&#9670;&nbsp;</a></span>block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">torch::Tensor&amp; quantit::btensor::block </td>
          <td>(</td>
          <td class="paramtype">const index_list &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access the block at the index given in argument. Allocate space for the block if necessary. </p>
<p>Throws a std::bad_argument if the block isn't allowed by the conservation law.</p>
<dl class="section return"><dt>Returns</dt><dd>torch::Tensor&amp; </dd></dl>

</div>
</div>
<a id="ab310947ff381e337d498cc343766a13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab310947ff381e337d498cc343766a13c">&#9670;&nbsp;</a></span>block_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">torch::Tensor&amp; quantit::btensor::block_at </td>
          <td>(</td>
          <td class="paramtype">const index_list &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access the block at the block index given in argument. </p>
<p>Throws a std::out_of_range if the block isn't allocated or allowed.</p>
<dl class="section return"><dt>Returns</dt><dd>torch::Tensor&amp; </dd></dl>

</div>
</div>
<a id="a7831359050b455e8bf4ead7bf205a1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7831359050b455e8bf4ead7bf205a1ae">&#9670;&nbsp;</a></span>block_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quantit::btensor::block_increment </td>
          <td>(</td>
          <td class="paramtype">btensor::index_list &amp;&#160;</td>
          <td class="paramname"><em>block_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>increment a block index for this tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_index</td><td>reference to the block index to increment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1720ff8aa74853ae8bb00909342b6776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1720ff8aa74853ae8bb00909342b6776">&#9670;&nbsp;</a></span>block_quantities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structquantit_1_1btensor_1_1const__block__prop__view.html">const_block_qtt_view</a> quantit::btensor::block_quantities </td>
          <td>(</td>
          <td class="paramtype">const index_list &amp;&#160;</td>
          <td class="paramname"><em>block_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain a view on the conserved quantities of each indices of a block with the block index given in argument </p>
<p>the conserved quantity for any block can be accessed that way, whether non-zero values are allowed or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_index</td><td>index of the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_block_qtt_view </dd></dl>

</div>
</div>
<a id="a18efb9612ab0b9c34f438f0197abc502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18efb9612ab0b9c34f438f0197abc502">&#9670;&nbsp;</a></span>block_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structquantit_1_1btensor_1_1const__block__prop__view.html">const_block_size_view</a> quantit::btensor::block_sizes </td>
          <td>(</td>
          <td class="paramtype">const index_list &amp;&#160;</td>
          <td class="paramname"><em>block_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain a view on the size of the block. </p>
<p>The size of any block can be accessed in this manner, whether non-zero values are allowed or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_block_size_view </dd></dl>

</div>
</div>
<a id="a18334e24f0068037814d8b060c60a0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18334e24f0068037814d8b060c60a0fc">&#9670;&nbsp;</a></span>blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classquantit_1_1flat__map.html">block_list_t</a>&amp; quantit::btensor::blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reference to the raw block list. </p>
<dl class="section return"><dt>Returns</dt><dd>const block_list_t&amp; </dd></dl>

</div>
</div>
<a id="aaba4b107e02154ce231380c1bb844766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba4b107e02154ce231380c1bb844766">&#9670;&nbsp;</a></span>check_tensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string quantit::btensor::check_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the tensor is correct. </p>
<p>No forbidden element allocated, torch tensor sizes matches their sectors sizes, etc.</p>
<p>return a string explaining violations.</p>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

</div>
</div>
<a id="a7ecbb590915372481349263bcc60cfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecbb590915372481349263bcc60cfd8">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::conj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the complex conjugate of this tensor and inverse the conserved quantities </p>
<p>For non complex type, the only the conserved quantities are modified. Those two operation are grouped together because in the context of tensor networks for quantum mechanics. the adjoint operation conjugate the values and inverse the conserved quantities. The adjoint also transpose the opterator or state, but the effect of the transposition of a network on its constituant tensor depends storngly on the structure of the network and must be done on a case by case basis.</p>
<p>grouping those two operation together is necessary to bring the textual difference in an implementation of an algorithm for torch::Tensor and <a class="el" href="classquantit_1_1btensor.html" title="btensor is a type meant to represent block sparse tensor with conservation laws. The conservation law...">quantit::btensor</a></p>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<a id="a902003e818128aef05e5e6a39ac77501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902003e818128aef05e5e6a39ac77501">&#9670;&nbsp;</a></span>conj_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::conj_only </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the complex conjugate of this tensor </p>
<p>For non complex type, the output is identical to the input. The conserved quantities are unaffected.</p>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<a id="aef10a4a7f737d8d45fb4e457440bf7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef10a4a7f737d8d45fb4e457440bf7de">&#9670;&nbsp;</a></span>cval_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::cval_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts the conserved quantities of one dimension of the tensor, applies the opposite shift to the conservation rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>shift to apply </td></tr>
    <tr><td class="paramname">dim</td><td>dimension to which the shift is applied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a037f8cc269cc93d75d84a95fbb0b16a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037f8cc269cc93d75d84a95fbb0b16a2">&#9670;&nbsp;</a></span>cval_shift_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::cval_shift_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts the conserved quantities of one dimension of the tensor, applies the opposite shift to the conservation rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>shift to apply </td></tr>
    <tr><td class="paramname">dim</td><td>dimension to which the shift is applied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a399cee30857b6b711c46817bbc0a9c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399cee30857b6b711c46817bbc0a9c56">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t quantit::btensor::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the rank of the tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>int64_t </dd></dl>

</div>
</div>
<a id="ad9a02622134dc835f3a333bac282a1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a02622134dc835f3a333bac282a1cb">&#9670;&nbsp;</a></span>element_index_decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;index_list, index_list&gt; quantit::btensor::element_index_decompose </td>
          <td>(</td>
          <td class="paramtype">const index_list &amp;&#160;</td>
          <td class="paramname"><em>element_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>split an index adressing an element within the full tensor into a block index, block-element index pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;index_list,index_list&gt; </dd></dl>

</div>
</div>
<a id="a0584d58aef82ff1994c454d5644142e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0584d58aef82ff1994c454d5644142e5">&#9670;&nbsp;</a></span>full_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;torch::indexing::TensorIndex&gt; quantit::btensor::full_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btensor::index_list &amp;&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the slices associated with a block in a full tensor with the same shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td></td></tr>
    <tr><td class="paramname">block</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;torch::indexing::TensorIndex&gt; </dd></dl>

</div>
</div>
<a id="aa058a2117553c629ce362eb711945e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa058a2117553c629ce362eb711945e58">&#9670;&nbsp;</a></span>index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::index </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a view on the block tensor. </p>
<p>The view on the btensor is itself a btensor. The underlying non-zero blocks are shared, new blocks cannot be added to the original tensor this way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indicesa</td><td>list of torch's index class, allow for slices, ellipsis, and index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor view on the original tensor </dd></dl>

</div>
</div>
<a id="ab59f73f7c6380e0bd8ca60e576d4b8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59f73f7c6380e0bd8ca60e576d4b8d2">&#9670;&nbsp;</a></span>index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::index </td>
          <td>(</td>
          <td class="paramtype">torch::ArrayRef&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a view on the block tensor. </p>
<p>The view on the btensor is itself a btensor. The underlying non-zero blocks are shared, new blocks cannot be added to the original tensor this way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>torch's index class, allow for slices, ellipsis, boolean, tensors, and simple index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor view on the original tensor </dd></dl>

</div>
</div>
<a id="abf801ccfc47e2cea549de96560345924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf801ccfc47e2cea549de96560345924">&#9670;&nbsp;</a></span>index_put_() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::index_put_ </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elements insertion operator, for block tensor. </p>
<p>The input tensor block structure must match the view's block structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>list of torch's index class, allow for slices, ellipsis, and simple index. </td></tr>
    <tr><td class="paramname">rhs</td><td>tensor of values to insert, it's shape must match the view described by the indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; reference to this </dd></dl>

</div>
</div>
<a id="a89aa8e2f2b22575d4927170457d44a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89aa8e2f2b22575d4927170457d44a30">&#9670;&nbsp;</a></span>index_put_() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::index_put_ </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elements insertion operator, for scalars. </p>
<p>If the index describes multiple elements, all the element that respect the conservation law are set to the supplied value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>list of torch's index class, allow for slices, ellipsis, and simple index. </td></tr>
    <tr><td class="paramname">rhs</td><td>tensor of values to insert, it's shape must match the view described by the indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; reference to this </dd></dl>

</div>
</div>
<a id="a6fc6df002361366fd2a92b8719114ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc6df002361366fd2a92b8719114ebf">&#9670;&nbsp;</a></span>index_put_() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::index_put_ </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elements insertion operator, for basic torch tensor. </p>
<p>The input tensor is sliced into blocks. elements of the input tensors disallowed by the conservation law are silently droped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>list of torch's index class, allow for slices, ellipsis, and simple index. </td></tr>
    <tr><td class="paramname">rhs</td><td>tensor of values to insert, it's shape must match the view described by the indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; reference to this </dd></dl>

</div>
</div>
<a id="a0a73b856d0a4da81209ed45b483bba4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a73b856d0a4da81209ed45b483bba4a">&#9670;&nbsp;</a></span>index_put_() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::index_put_ </td>
          <td>(</td>
          <td class="paramtype">torch::ArrayRef&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elements insertion operator, for block tensor. </p>
<p>The input tensor block structure must match the view's block structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>list of torch's index class, allow for slices, ellipsis, and simple index. </td></tr>
    <tr><td class="paramname">rhs</td><td>tensor of values to insert, it's shape must match the view described by the indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; reference to this </dd></dl>

</div>
</div>
<a id="a9f7fed837898e36e46e003819b5183ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7fed837898e36e46e003819b5183ca">&#9670;&nbsp;</a></span>index_put_() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::index_put_ </td>
          <td>(</td>
          <td class="paramtype">torch::ArrayRef&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elements insertion operator, for scalars. </p>
<p>If the index describes multiple elements, all the element that respect the conservation law are set to the supplied value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>list of torch's index class, allow for slices, ellipsis, and simple index. </td></tr>
    <tr><td class="paramname">rhs</td><td>tensor of values to insert, it's shape must match the view described by the indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; reference to this </dd></dl>

</div>
</div>
<a id="a8ee26adff8b22f7c20d85706b0deda4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee26adff8b22f7c20d85706b0deda4a">&#9670;&nbsp;</a></span>index_put_() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::index_put_ </td>
          <td>(</td>
          <td class="paramtype">torch::ArrayRef&lt; torch::indexing::TensorIndex &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elements insertion operator, for basic torch tensor. </p>
<p>The input tensor is sliced into blocks. elements of the input tensors disallowed by the conservation law are silently droped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>list of torch's index class, allow for slices, ellipsis, and simple index. </td></tr>
    <tr><td class="paramname">rhs</td><td>tensor of values to insert, it's shape must match the view described by the indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; reference to this </dd></dl>

</div>
</div>
<a id="a1742f2450d18a58b0508799e9d48c469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1742f2450d18a58b0508799e9d48c469">&#9670;&nbsp;</a></span>inverse_cvals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::inverse_cvals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new tensor with its section rule and all its conserved quantities inversed. </p>
<p>Conserved quantities must be inversed when doing the hermitian conjugation of an operator.</p>
<p>Caution: The blocks of the new tensors are shallow copies of the original.</p>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<a id="a5960100f9b13fb48702b30644283d9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5960100f9b13fb48702b30644283d9a4">&#9670;&nbsp;</a></span>inverse_cvals_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::inverse_cvals_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inverse the selection rule and all the conserved quantities of this btensor. </p>
<p>Conserved quantities must be inversed when doing the hermitian conjugation of an operator.</p>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; </dd></dl>

</div>
</div>
<a id="a01c490238e0022b585dc430b13ec7dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c490238e0022b585dc430b13ec7dd1">&#9670;&nbsp;</a></span>item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btensor::Scalar quantit::btensor::item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the tensor contain a single element, return a scalar object. </p>
<dl class="section return"><dt>Returns</dt><dd>btensor::Scalar </dd></dl>

</div>
</div>
<a id="ac88360f21d921bc565957aa94c292e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88360f21d921bc565957aa94c292e3e">&#9670;&nbsp;</a></span>mul_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::mul_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>in-place element wise product, with broadcasting on size 1 dimensions. </p>
<p>Will throw an error if the rank of this is smaller than the would be output. I suspect this is a bug in torch. There's no reason not to adapt the rank of the tensor, from a storage perspective this isn't different from increasing the size of one dimenion, which this function can do.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; </dd></dl>

</div>
</div>
<a id="a6c5ce2bf6e0c189de1475db903fcef87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5ce2bf6e0c189de1475db903fcef87">&#9670;&nbsp;</a></span>neutral_shape_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::neutral_shape_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<a id="a6934183b8e07a5548b6af93fa6d30676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6934183b8e07a5548b6af93fa6d30676">&#9670;&nbsp;</a></span>non_conserving_cval_shift_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::non_conserving_cval_shift_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts the conserved quantities of one dimension of the tensor without regards for the conservation laws. </p>
<p>Can only be applied to empty tensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>shift to apply </td></tr>
    <tr><td class="paramname">dim</td><td>dimension to which the shift is applied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1f9b62db4386110f2b9db59615638f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f9b62db4386110f2b9db59615638f1">&#9670;&nbsp;</a></span>reserve_space_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quantit::btensor::reserve_space_ </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve space in the block list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>number of blocks for which to reserve space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391e6d73f73bc486c0f080e6cd8ab7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391e6d73f73bc486c0f080e6cd8ab7a8">&#9670;&nbsp;</a></span>reshape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::reshape </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape the btensor into a btensor of a lower rank. </p>
<p>This function is significantly different from torch's equivalent, both in the required input and the resulting tensor. The reshaping is done once on the block structure and once on the block content. Consequently, the content is permuted relative to the same reshape done on a regular tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_group</td><td>each integer mark the first element of the next bundle of index to group for exemple: [3,4,5] would group index 0,1,2 into a single new index, leave 3 and 4 as they are, and group 5..rank-1 together </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor reshaped tensor </dd></dl>

</div>
</div>
<a id="a444e6084e8589ae5ae4236cb35c27f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444e6084e8589ae5ae4236cb35c27f01">&#9670;&nbsp;</a></span>reshape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::reshape </td>
          <td>(</td>
          <td class="paramtype">torch::IntArrayRef&#160;</td>
          <td class="paramname"><em>index_group</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshape the btensor into a btensor of a lower rank. </p>
<p>This function is significantly different from torch's equivalent, both in the required input and the resulting tensor. The reshaping is done once on the block structure and once on the block content. Consequently, the content is permuted relative to the same reshape done on a regular tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_group</td><td>each integer mark the first element of the next bundle of index to group for exemple: [3,4,5] would group index 0,1,2 into a single new index, leave 3 and 4 as they are, and group 5..rank-1 together </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor reshaped tensor </dd></dl>

</div>
</div>
<a id="a5c0f704cd6343d24b4a42031e2e22bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0f704cd6343d24b4a42031e2e22bc5">&#9670;&nbsp;</a></span>reshape_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;reshape_mode mode = reshape_mode::dims_only&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::reshape_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reshape the tensor into the shape of the supplied tensor. </p>
<p>The supplied tensor must have conserved quantities compatible with this. Therefore, the conserved quantities of the blocks of this must factorize into the conserved quantity of the matching block of the arguement. Can reshape into a tensor of greater rank.</p>
<p>When overwrite_c_vals is true, the selection rule will be overwritten with the one of the input tensor. The non-zero blocks of this must satisfy the selection rule of the proposed output shape.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">reshaping</td><td>mode, modify the conserved quantities on the indices only by default, overwrite the selection rule with reshape_mode::overwrite_cvals </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Tensor with the target shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor Reshaped tensor </dd></dl>

</div>
</div>
<a id="af88cd6bb654832133a7dfbefa8f629c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88cd6bb654832133a7dfbefa8f629c1">&#9670;&nbsp;</a></span>section_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t quantit::btensor::section_number </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of sections in a given dimension </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="ab35ce624f7923057fe83535f2a72b87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35ce624f7923057fe83535f2a72b87d">&#9670;&nbsp;</a></span>section_numbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto&amp; quantit::btensor::section_numbers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of section for all the dimensions, in order. </p>
<dl class="section return"><dt>Returns</dt><dd>const auto&amp; </dd></dl>

</div>
</div>
<a id="a8eb0fa9598edbcca7bd461e828efcae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb0fa9598edbcca7bd461e828efcae9">&#9670;&nbsp;</a></span>set_selection_rule_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::set_selection_rule_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the selection rule of the block tensor. </p>
<p>Only works on empty btensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; </dd></dl>

</div>
</div>
<a id="aee959f8823a1ccb165e6ddeced75b0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee959f8823a1ccb165e6ddeced75b0f6">&#9670;&nbsp;</a></span>shape_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::shape_from </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an empty tensor from selected dimensions of this. Minimum necessary set of feature for tensor network reshape. </p>
<p>Basic version of index, it can only discard whole dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>List of dimensions, put -1 to keep the dimension, specify the index to keep otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<a id="af4e02d410e3e3c2f32903b352917877a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e02d410e3e3c2f32903b352917877a">&#9670;&nbsp;</a></span>shift_selection_rule_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a>&amp; quantit::btensor::shift_selection_rule_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classquantit_1_1vquantity.html">any_quantity_cref</a>&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the selection rule by the value of shift. Can only be done on empty tensors . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor&amp; </dd></dl>

</div>
</div>
<a id="a210be19c2e6965f45a5d028a27edb2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210be19c2e6965f45a5d028a27edb2df">&#9670;&nbsp;</a></span>sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int64_t&gt; quantit::btensor::sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the list of the sizes along each dimensions of the tensor </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int64_t&gt; </dd></dl>

</div>
</div>
<a id="ad0a016599b6c1ba4a98111075081acda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a016599b6c1ba4a98111075081acda">&#9670;&nbsp;</a></span>tensor_product_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::tensor_product_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the shape of the tensor product of this with the other tensor. store the shape information in an empty btensor </p>
<p>If you want to actually proceed to the tensor product, use tensordot with no contracted</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<a id="a6a97b9d52b04fe14bf7bb5a55a810382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a97b9d52b04fe14bf7bb5a55a810382">&#9670;&nbsp;</a></span>to_dense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">torch::Tensor quantit::btensor::to_dense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the block tensor to a regular torch tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>torch::Tensor </dd></dl>

</div>
</div>
<a id="a6176a831cc6ebf1769453bbd38846e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6176a831cc6ebf1769453bbd38846e3f">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> quantit::btensor::transpose </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>exchange the order of two indices. </p>
<p>Simplify to a matrix transpose for tensors of rank 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim0</td><td></td></tr>
    <tr><td class="paramname">dim1</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac56cbb1dbc7e3b803e8e44aca0a02c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56cbb1dbc7e3b803e8e44aca0a02c45">&#9670;&nbsp;</a></span>eye_like</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> eye_like </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c10::TensorOptions&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a matrix with the identity matrix for every permited block on the diagonnal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape of the matrix to construct </td></tr>
    <tr><td class="paramname">opt</td><td>tensor options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>btensor </dd></dl>

</div>
</div>
<a id="a17d65b7567711e3a99727df6139563d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d65b7567711e3a99727df6139563d8">&#9670;&nbsp;</a></span>sparse_zeros_like</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classquantit_1_1btensor.html">btensor</a> sparse_zeros_like </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classquantit_1_1btensor.html">btensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c10::TensorOptions&#160;</td>
          <td class="paramname"><em>opt</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an empty (no allocatred blocks) btensor with the same shape and selection rule as the imput tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tens</td><td>shape specifying tensor </td></tr>
    <tr><td class="paramname">opt</td><td>tensor options, specified option overwrite those copied from tens </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>empty btensor </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/alex/project/quantt/include/blockTensor/<a class="el" href="btensor_8h_source.html">btensor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
