<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacequantit" kind="namespace" language="C++">
    <compoundname>quantit</compoundname>
    <innerclass refid="classquantit_1_1btensor" prot="public">quantit::btensor</innerclass>
    <innerclass refid="structquantit_1_1torch__shape" prot="public">quantit::torch_shape</innerclass>
    <innerclass refid="classquantit_1_1bad__selection__rule" prot="public">quantit::bad_selection_rule</innerclass>
    <innerclass refid="classquantit_1_1non__matching__cvals" prot="public">quantit::non_matching_cvals</innerclass>
    <innerclass refid="classquantit_1_1non__matching__sizes" prot="public">quantit::non_matching_sizes</innerclass>
    <innerclass refid="classquantit_1_1flat__map" prot="public">quantit::flat_map</innerclass>
    <innerclass refid="structquantit_1_1BOOL" prot="public">quantit::BOOL</innerclass>
    <innerclass refid="classquantit_1_1any__quantity" prot="public">quantit::any_quantity</innerclass>
    <innerclass refid="classquantit_1_1vquantity" prot="public">quantit::vquantity</innerclass>
    <innerclass refid="classquantit_1_1quantity" prot="public">quantit::quantity</innerclass>
    <innerclass refid="structquantit_1_1is__conc__cgroup__impl" prot="public">quantit::is_conc_cgroup_impl</innerclass>
    <innerclass refid="structquantit_1_1is__conc__cgroup__impl_3_01quantity_3_01S_8_8_8_01_4_01_4" prot="public">quantit::is_conc_cgroup_impl&lt; quantity&lt; S... &gt; &gt;</innerclass>
    <innerclass refid="classquantit_1_1any__quantity__vector" prot="public">quantit::any_quantity_vector</innerclass>
    <innerclass refid="classquantit_1_1blocklist" prot="public">quantit::blocklist</innerclass>
    <innerclass refid="classquantit_1_1vquantity__vector" prot="public">quantit::vquantity_vector</innerclass>
    <innerclass refid="classquantit_1_1quantity__vector" prot="public">quantit::quantity_vector</innerclass>
    <innerclass refid="classquantit_1_1dmrg__logger" prot="public">quantit::dmrg_logger</innerclass>
    <innerclass refid="classquantit_1_1dmrg__default__logger" prot="public">quantit::dmrg_default_logger</innerclass>
    <innerclass refid="classquantit_1_1dmrg__log__simple" prot="public">quantit::dmrg_log_simple</innerclass>
    <innerclass refid="classquantit_1_1dmrg__log__sweeptime" prot="public">quantit::dmrg_log_sweeptime</innerclass>
    <innerclass refid="structquantit_1_1dmrg__options" prot="public">quantit::dmrg_options</innerclass>
    <innerclass refid="classquantit_1_1vector__lift" prot="public">quantit::vector_lift</innerclass>
    <innerclass refid="classquantit_1_1MPT" prot="public">quantit::MPT</innerclass>
    <innerclass refid="classquantit_1_1MPS" prot="public">quantit::MPS</innerclass>
    <innerclass refid="classquantit_1_1MPO" prot="public">quantit::MPO</innerclass>
    <innerclass refid="classquantit_1_1bMPT" prot="public">quantit::bMPT</innerclass>
    <innerclass refid="classquantit_1_1bMPS" prot="public">quantit::bMPS</innerclass>
    <innerclass refid="classquantit_1_1bMPO" prot="public">quantit::bMPO</innerclass>
    <innerclass refid="structquantit_1_1dependant__tensor__network" prot="public">quantit::dependant_tensor_network</innerclass>
    <innerclass refid="structquantit_1_1dependant__tensor__network_3_01btensor_01_4" prot="public">quantit::dependant_tensor_network&lt; btensor &gt;</innerclass>
    <innerclass refid="structquantit_1_1dependant__tensor__network_3_01torch_1_1Tensor_01_4" prot="public">quantit::dependant_tensor_network&lt; torch::Tensor &gt;</innerclass>
    <innerclass refid="structquantit_1_1dependant__tensor__network_3_01S_00_01std_1_1enable__if__t_3_01std_1_1is__base_060016cbe70a4089cd834cde17bb5eac" prot="public">quantit::dependant_tensor_network&lt; S, std::enable_if_t&lt; std::is_base_of_v&lt; vector_lift&lt; S, torch::Tensor &gt;, S &gt; &gt; &gt;</innerclass>
    <innerclass refid="structquantit_1_1dependant__tensor__network_3_01S_00_01std_1_1enable__if__t_3_01std_1_1is__base_7caa039768c7fc487ea8fbc6fa9338de" prot="public">quantit::dependant_tensor_network&lt; S, std::enable_if_t&lt; std::is_base_of_v&lt; vector_lift&lt; S, btensor &gt;, S &gt; &gt; &gt;</innerclass>
    <innerclass refid="structquantit_1_1and__" prot="public">quantit::and_</innerclass>
    <innerclass refid="structquantit_1_1and___3_01Cond_00_01Conds_8_8_8_01_4" prot="public">quantit::and_&lt; Cond, Conds... &gt;</innerclass>
    <innerclass refid="structquantit_1_1or__" prot="public">quantit::or_</innerclass>
    <innerclass refid="structquantit_1_1or___3_01cond_00_01conds_8_8_8_01_4" prot="public">quantit::or_&lt; cond, conds... &gt;</innerclass>
    <innernamespace refid="namespacequantit_1_1conserved">quantit::conserved</innernamespace>
    <innernamespace refid="namespacequantit_1_1details">quantit::details</innernamespace>
    <innernamespace refid="namespacequantit_1_1LA__helpers">quantit::LA_helpers</innernamespace>
    <innernamespace refid="namespacequantit_1_1vQuantiT__iterator">quantit::vQuantiT_iterator</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="btensor_8h_1ac803ed5b47e0553e00a255b04e290b59" prot="public" static="no" strong="yes">
        <type></type>
        <name>btensor_size</name>
        <enumvalue id="btensor_8h_1ac803ed5b47e0553e00a255b04e290b59a2ffe4e77325d9a7152f7086ea7aa5114" prot="public">
          <name>max</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="40" column="1" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="41" bodyend="43"/>
      </memberdef>
      <memberdef kind="enum" id="btensor_8h_1a2728914a998e15744734cec39ed6e44c" prot="public" static="no" strong="yes">
        <type></type>
        <name>reshape_mode</name>
        <enumvalue id="btensor_8h_1a2728914a998e15744734cec39ed6e44cad403b423ade78c02b4d8a598ad4ffc77" prot="public">
          <name>dims_only</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="btensor_8h_1a2728914a998e15744734cec39ed6e44cad41d8f5bd03c75711f60363a08ff5c5e" prot="public">
          <name>overwrite_c_vals</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="44" column="1" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="45" bodyend="48"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="btensor_8h_1ae659fee9fd3f82ce42a5c06e3ac5961c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class A</type>
          </param>
        </templateparamlist>
        <type>std::remove_cv_t&lt; std::remove_reference_t&lt; A &gt; &gt;</type>
        <definition>using quantit::remove_cvref_t = typedef std::remove_cv_t&lt;std::remove_reference_t&lt;A&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>remove_cvref_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1023" column="1" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1023" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="cquantity_8h_1ae7a47e244b48ea606d80ce22f9847857" prot="public" static="no">
        <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
        <definition>using quantit::any_quantity_cref = typedef const vquantity &amp;</definition>
        <argsstring></argsstring>
        <name>any_quantity_cref</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="32" column="1" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="cquantity_8h_1ae13bd61a1fc27b404192b628eeb6c732" prot="public" static="no">
        <type><ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
        <definition>using quantit::any_quantity_ref = typedef vquantity &amp;</definition>
        <argsstring></argsstring>
        <name>any_quantity_ref</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="33" column="1" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="templateMeta_8h_1a2abf4e297d61d2fd66aa54719f7cc538" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>typename <ref refid="structquantit_1_1details_1_1detector" kindref="compound">details::detector</ref>&lt; <ref refid="structquantit_1_1details_1_1nonesuch" kindref="compound">details::nonesuch</ref>, void, Op, Args... &gt;::value_t</type>
        <definition>using quantit::is_detected = typedef typename details::detector&lt;details::nonesuch, void, Op, Args...&gt;::value_t</definition>
        <argsstring></argsstring>
        <name>is_detected</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="56" column="1" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="templateMeta_8h_1af71156a4d1289d3784882f505341de87" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>typename <ref refid="structquantit_1_1details_1_1detector" kindref="compound">details::detector</ref>&lt; <ref refid="structquantit_1_1details_1_1nonesuch" kindref="compound">details::nonesuch</ref>, void, Op, Args... &gt;::type</type>
        <definition>using quantit::detected_t = typedef typename details::detector&lt;details::nonesuch, void, Op, Args...&gt;::type</definition>
        <argsstring></argsstring>
        <name>detected_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="59" column="1" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="59" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="templateMeta_8h_1ab95d0ae196901d86cb3273ec0b00cac5" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class Default</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structquantit_1_1details_1_1detector" kindref="compound">details::detector</ref>&lt; Default, void, Op, Args... &gt;</type>
        <definition>using quantit::detected_or = typedef details::detector&lt;Default, void, Op, Args...&gt;</definition>
        <argsstring></argsstring>
        <name>detected_or</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="62" column="1" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="templateMeta_8h_1a54eca4d0bc516622d4e20f77b8bb23ae" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class Default</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>typename <ref refid="structquantit_1_1details_1_1detector" kindref="compound">detected_or</ref>&lt; Default, Op, Args... &gt;::type</type>
        <definition>using quantit::detected_or_t = typedef typename detected_or&lt;Default, Op, Args...&gt;::type</definition>
        <argsstring></argsstring>
        <name>detected_or_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="67" column="1" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="67" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="templateMeta_8h_1aeda0a862acd8712754a1ad49ee93eb39" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class Expected</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>::std::is_same&lt; Expected, detected_t&lt; Op, Args... &gt; &gt;</type>
        <definition>using quantit::is_detected_exact = typedef ::std::is_same&lt;Expected, detected_t&lt;Op, Args...&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_detected_exact</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="69" column="1" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="69" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="templateMeta_8h_1a4711729d249a9df9abce47f2c26d7759" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class To</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>::std::is_convertible&lt; detected_t&lt; Op, Args... &gt;, To &gt;</type>
        <definition>using quantit::is_detected_convertible = typedef ::std::is_convertible&lt;detected_t&lt;Op, Args...&gt;, To&gt;</definition>
        <argsstring></argsstring>
        <name>is_detected_convertible</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="73" column="1" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="73" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="templateMeta_8h_1a7a6f2fb0e5b0e0d262719b11b111cecc" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool quantit::is_detected_v</definition>
        <argsstring></argsstring>
        <name>is_detected_v</name>
        <initializer>= is_detected&lt;Op, Args...&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="65" column="16" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="65" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="templateMeta_8h_1a69b9b88aedd3f9f74dd3c032e50af24d" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class Expected</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool quantit::is_detected_exact_v</definition>
        <argsstring></argsstring>
        <name>is_detected_exact_v</name>
        <initializer>= is_detected_exact&lt;Expected, Op, Args...&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="71" column="16" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="71" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="templateMeta_8h_1afce887eed1fe2b31034bb79ac49b0bdf" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class To</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool quantit::is_detected_convertible_v</definition>
        <argsstring></argsstring>
        <name>is_detected_convertible_v</name>
        <initializer>= is_detected_convertible&lt;To, Op, Args...&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="75" column="16" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="75" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="btensor_8h_1a04ba1bc4be20af6d402d59f512cb6199" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool quantit::any_truth</definition>
        <argsstring>(const T &amp;in)</argsstring>
        <name>any_truth</name>
        <param>
          <type>const T &amp;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
<para>if any of the element in the range convert to true, return true. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true at least one element converts to true </para>
</simplesect>
<simplesect kind="return"><para>false no element convert to true </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="56" column="6" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="56" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a591f5cf63db1ede790bf91be2e0ebad2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::sparse_zeros_like</definition>
        <argsstring>(const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>sparse_zeros_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>create an empty (no allocatred blocks) btensor with the same shape and selection rule as the imput tensor </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tens</parametername>
</parameternamelist>
<parameterdescription>
<para>shape specifying tensor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>opt</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor options, specified option overwrite those copied from tens </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>empty btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="985" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="985" bodyend="990"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a07e70c0feb918434a85ef1db779dde9a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::shape_from</definition>
        <argsstring>(const std::vector&lt; btensor &gt; &amp;btens_list)</argsstring>
        <name>shape_from</name>
        <param>
          <type>const std::vector&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt; &amp;</type>
          <declname>btens_list</declname>
        </param>
        <briefdescription>
<para>Construct an empty block tensor from the supplied btensors. </para>
        </briefdescription>
        <detaileddescription>
<para>The output structure is the same as that of the tensor product of the supplied tensors.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>btens_list</parametername>
</parameternamelist>
<parameterdescription>
<para>list of block tensors </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="999" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="999" bodyend="1012"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ad28da49bd7baef2ed25897b74f103f70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::disambiguated_shape_from</definition>
        <argsstring>(const std::vector&lt; btensor &gt; &amp;btens_list)</argsstring>
        <name>disambiguated_shape_from</name>
        <param>
          <type>const std::vector&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt; &amp;</type>
          <declname>btens_list</declname>
        </param>
        <briefdescription>
<para>When in a context where the method <ref refid="classquantit_1_1btensor_1aee959f8823a1ccb165e6ddeced75b0f6" kindref="member">btensor::shape_from</ref> is accessible without explicitly specifying the object, the compiler has trouble selecting the correct function. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>btens_list</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1020" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1020" bodyend="1020"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aca438175ec5b804de21a5e20f91c6c74" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::shape_from</definition>
        <argsstring>(const btensor &amp;tens, const std::vector&lt; int64_t &gt; &amp;inds)</argsstring>
        <name>shape_from</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>const std::vector&lt; int64_t &gt; &amp;</type>
          <declname>inds</declname>
        </param>
        <briefdescription>
<para>create a shape (empty btensor) from the input tensor and the list of index. </para>
        </briefdescription>
        <detaileddescription>
<para>In the list of index, dimensions can be kept as they are by specifying -1, otherwise only the element with the specified index value are kept along that dimensions, reducing the output tensor&apos;s rank. The quantum number of the reduced index modifies the selection rule of the resulting shape. Since this function result in an empty btensor, the selection rule of the tensor can be modified freely after the it is created but before elements are put into it.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tens</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inds</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1042" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1042" bodyend="1042"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a9c025f9eb1860341fb5b1801ee5c173c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::get_section_cval</definition>
        <argsstring>(const torch_shape &amp;, size_t, size_t)</argsstring>
        <name>get_section_cval</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
        </param>
        <param>
          <type>size_t</type>
        </param>
        <param>
          <type>size_t</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1065" column="21" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1065" bodyend="1065"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1afbfece654af4709842a23412bd7096ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
        <definition>any_quantity_cref quantit::get_section_cval</definition>
        <argsstring>(const btensor &amp;tens, size_t dim, size_t section)</argsstring>
        <name>get_section_cval</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>section</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1066" column="26" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1066" bodyend="1069"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aa0bf18eb14db1c16612ba0aa8ee8cecb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref></type>
        <definition>torch_shape quantit::shape_from</definition>
        <argsstring>(std::initializer_list&lt; torch_shape &gt; shapes)</argsstring>
        <name>shape_from</name>
        <param>
          <type>std::initializer_list&lt; <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &gt;</type>
          <declname>shapes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1070" column="13" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1070" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a06bd0541bb0099a0a2d28c65bcb532e2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>class Enabled</type>
            <defval>std::enable_if_t&lt;                             std::conjunction_v&lt;std::is_convertible&lt;remove_cvref_t&lt;Args&gt;, torch_shape&gt;...&gt; or                             std::conjunction_v&lt;std::is_same&lt;remove_cvref_t&lt;Args&gt;, btensor&gt;...&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto quantit::shape_from</definition>
        <argsstring>(const Args &amp;...args)</argsstring>
        <name>shape_from</name>
        <param>
          <type>const Args &amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Construct an empty block tensor or <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> from the supplied shapes. </para>
        </briefdescription>
        <detaileddescription>
<para>if all the input are btensors, the output an empty btensors. if all the input are <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref>, the output is a <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> object. The output shape is the same as that of the tensor product of the supplied tensors.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>btensors or <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>shapes </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>shape </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1085" column="13" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1085" bodyend="1092"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a4ba1f8c3e0dda3cb0d25b5c0947a1a87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref></type>
        <definition>torch_shape quantit::shape_from</definition>
        <argsstring>(const torch_shape &amp;shape, const std::vector&lt; int64_t &gt; inds)</argsstring>
        <name>shape_from</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>const std::vector&lt; int64_t &gt;</type>
          <declname>inds</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1093" column="13" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1093" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a1d8827d7a29d14ce3259eece19aa738c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t quantit::get_refcount</definition>
        <argsstring>(const torch::Tensor &amp;tens)</argsstring>
        <name>get_refcount</name>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1095" column="8" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1095" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a211befac8ef265e7dba9f02fe7115658" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(btensor &amp;a, btensor &amp;b)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1097" column="13" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1097" bodyend="1097"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aea9de5e0850b640add46ce8c90837c47" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::tensordot</definition>
        <argsstring>(const btensor &amp;left, const btensor &amp;right, torch::IntArrayRef dims_left, torch::IntArrayRef dims_right)</argsstring>
        <name>tensordot</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims_left</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims_right</declname>
        </param>
        <briefdescription>
<para>tensor contraction, or tensor dot product. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>left</parametername>
</parameternamelist>
<parameterdescription>
<para>the left tensor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>right</parametername>
</parameternamelist>
<parameterdescription>
<para>the right tensor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims_left</parametername>
</parameternamelist>
<parameterdescription>
<para>dimensions to contract on the left tensor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims_right</parametername>
</parameternamelist>
<parameterdescription>
<para>dimensions to contract on the right tensor </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor tensor resulting from the contraction </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1228" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1228" bodyend="1232"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1af356ab1bcbd6882712cefa40b31a00fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::tensorgdot</definition>
        <argsstring>(const btensor &amp;add, const btensor &amp;mul1, const btensor &amp;mul2, torch::IntArrayRef dims1, torch::IntArrayRef dims2, btensor::Scalar beta=1, btensor::Scalar alpha=1)</argsstring>
        <name>tensorgdot</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>add</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>mul1</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>mul2</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims1</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims2</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>beta</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>alpha</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>generalized tensor dot product, adds the result of the contraction to a copy of a specified tensor </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>add</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor into which the dot product is added </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul1</parametername>
</parameternamelist>
<parameterdescription>
<para>right tensor in the contraction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul2</parametername>
</parameternamelist>
<parameterdescription>
<para>left tensor in the contraction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims1</parametername>
</parameternamelist>
<parameterdescription>
<para>dimensions of mul1 to contract </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims2</parametername>
</parameternamelist>
<parameterdescription>
<para>dimension of mul2 to contract </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar factor to apply to the result of the contraction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar factor to apply to add </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1245" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1245" bodyend="1249"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a1120ddd84748fe26b0cca9d77330b2e7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::tensorgdot_</definition>
        <argsstring>(btensor &amp;add, const btensor &amp;mul1, const btensor &amp;mul2, torch::IntArrayRef dims1, torch::IntArrayRef dims2, btensor::Scalar beta=1, btensor::Scalar alpha=1)</argsstring>
        <name>tensorgdot_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>add</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>mul1</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>mul2</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims1</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims2</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>beta</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>alpha</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>in-place generalized tensor dot product, adds the result of the contraction to a specified tensor </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>add</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor into which the dot product is added </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul1</parametername>
</parameternamelist>
<parameterdescription>
<para>right tensor in the contraction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul2</parametername>
</parameternamelist>
<parameterdescription>
<para>left tensor in the contraction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims1</parametername>
</parameternamelist>
<parameterdescription>
<para>dimensions of mul1 to contract </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims2</parametername>
</parameternamelist>
<parameterdescription>
<para>dimension of mul2 to contract </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar factor to apply to the result of the contraction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar factor to apply to add </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor reference to the modified added to tensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1262" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1262" bodyend="1266"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a4ed96548714ee7374e07fca60e8758ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::sparse_zeros</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>sparse_zeros</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1268" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1268" bodyend="1272"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a41009aacf8e74883b989a2aa571eba0a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::zeros</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>zeros</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1273" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1273" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a3d8c43cb4c42a5cf333edb2f850a733a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::zeros_like</definition>
        <argsstring>(const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>zeros_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1274" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1274" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1abc863a9802d326d1e7c1b6ef148e68ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::ones</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>ones</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1275" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1275" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a360f461cb260db2c025dd2b0e09e797d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::ones_like</definition>
        <argsstring>(const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>ones_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1276" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1276" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ae185879281fef81aed3df5d2261be3d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::empty</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>empty</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1277" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1277" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a62b8099def3a452b84dad04738b4812c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::empty_like</definition>
        <argsstring>(const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>empty_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1278" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1278" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a39aad75338d494c765e1df2058dab19e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::rand</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>rand</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1279" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1279" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ae70898545e24793197b8f4ae6b6223cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::rand_like</definition>
        <argsstring>(const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>rand_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1280" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1280" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7ecad99296969b6755e3bebd5f8d306d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::full</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, btensor::Scalar fill_value, c10::TensorOptions opt={})</argsstring>
        <name>full</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>fill_value</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1281" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1281" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ad5b1e659c5691285d5e8605ea39c9df9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::full_like</definition>
        <argsstring>(const btensor &amp;tens, btensor::Scalar fill_value, c10::TensorOptions opt={})</argsstring>
        <name>full_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>fill_value</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1283" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1283" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7f5c868d61d47e8e61a566d26e00775a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint</definition>
        <argsstring>(int64_t low, int64_t high, const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>randint</name>
        <param>
          <type>int64_t</type>
          <declname>low</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1284" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1284" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1addfc111458f810937335a59442eeb2a0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, int64_t low, int64_t high, c10::TensorOptions opt={})</argsstring>
        <name>randint</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>low</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1286" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1286" bodyend="1290"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a2d1eb3ff6b8ca1c17263731c383f40cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint_like</definition>
        <argsstring>(int64_t low, int64_t high, const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>randint_like</name>
        <param>
          <type>int64_t</type>
          <declname>low</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1291" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1291" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a3b2695aa8e5d1ce13c1f16c243b50a46" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint_like</definition>
        <argsstring>(const btensor &amp;shape, int64_t low, int64_t high, c10::TensorOptions opt={})</argsstring>
        <name>randint_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>low</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1292" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1292" bodyend="1295"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7e6bb78dde8a5ae345d985d2ce3b240c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint</definition>
        <argsstring>(int64_t high, const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>randint</name>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1296" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1296" bodyend="1300"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7cae28e1f861522673f7576f30603314" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint_like</definition>
        <argsstring>(int64_t high, const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>randint_like</name>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1301" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1301" bodyend="1304"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a4a88504ddf97227b0b4bb1754acbc9c4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint_like</definition>
        <argsstring>(const btensor &amp;tens, int64_t high, c10::TensorOptions opt={})</argsstring>
        <name>randint_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1306" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1306" bodyend="1309"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a1bb08c13f49f2404fcf4786c6a6d3248" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randint</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, int64_t high, c10::TensorOptions opt={})</argsstring>
        <name>randint</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1310" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1310" bodyend="1314"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ad27bbb34b1e34d63c7b7b1920e0f9545" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::eye</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_n, c10::TensorOptions opt={})</argsstring>
        <name>eye</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_n</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>create a matrix with the identity matrix for every permited block on the diagonnal. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shape_n</parametername>
</parameternamelist>
<parameterdescription>
<para>shape descriptor, either rank 1 or 2. when the input is rank 1, it describes the row of an hermitian matrix </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>opt</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor options </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1322" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1322" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ae5e16702de254eb9555e66c58dc3043a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::eye_like</definition>
        <argsstring>(const btensor &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>eye_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>create a matrix with the identity matrix for every permited block on the diagonnal. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shape</parametername>
</parameternamelist>
<parameterdescription>
<para>shape of the matrix to construct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>opt</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor options </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1330" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1330" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a89168ebb643bcc1465250a5d4be70eba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randn</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, c10::TensorOptions opt={})</argsstring>
        <name>randn</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1332" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1332" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1abe58555fe2a7f4e14d8679b944727f65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::randn_like</definition>
        <argsstring>(const btensor &amp;tens, c10::TensorOptions opt={})</argsstring>
        <name>randn_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1333" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1333" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ad0fd6f5caa0163d5cd2a587dcb02f021" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::from_basic_tensor</definition>
        <argsstring>(const btensor::vec_list_t &amp;shape_spec, any_quantity selection_rule, const torch::Tensor &amp;values, const torch::Scalar cutoff=1e-16, c10::TensorOptions={})</argsstring>
        <name>from_basic_tensor</name>
        <param>
          <type>const btensor::vec_list_t &amp;</type>
          <declname>shape_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
          <declname>selection_rule</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const torch::Scalar</type>
          <declname>cutoff</declname>
          <defval>1e-16</defval>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1335" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1335" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1abefc94c06d0f31e958ff9d8663b2278d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::from_basic_tensor_like</definition>
        <argsstring>(const btensor &amp;shape, const torch::Tensor &amp;values, const torch::Scalar cutoff=1e-16, c10::TensorOptions={})</argsstring>
        <name>from_basic_tensor_like</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const torch::Scalar</type>
          <declname>cutoff</declname>
          <defval>1e-16</defval>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1337" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1337" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1af7451979ed47776c841e9850fd93d90f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::zeros_like</definition>
        <argsstring>(const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>zeros_like</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1340" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1340" bodyend="1343"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a11ea6b7a4b3887a062394a29e929dc16" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::eye_like</definition>
        <argsstring>(const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>eye_like</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1344" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1344" bodyend="1348"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ad36fbd16ec626583fefb264825398d02" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::ones_like</definition>
        <argsstring>(const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>ones_like</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1349" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1349" bodyend="1352"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a0b815295e4c4e2486e2c26334d1e1528" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::empty_like</definition>
        <argsstring>(const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>empty_like</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1353" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1353" bodyend="1356"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a2825a2565d3c0843c1c17c5f398a5fab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::rand_like</definition>
        <argsstring>(const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>rand_like</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1357" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1357" bodyend="1360"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a07cd8c8299465a65c980b0d59a78a4ab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::full_like</definition>
        <argsstring>(const torch_shape &amp;shape, btensor::Scalar fill, c10::TensorOptions opt={})</argsstring>
        <name>full_like</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>fill</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1361" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1361" bodyend="1364"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7f67b53131cb6e31a6fa1c8a4d54e8cc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::randint_like</definition>
        <argsstring>(int64_t low, int64_t high, const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>randint_like</name>
        <param>
          <type>int64_t</type>
          <declname>low</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1365" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1365" bodyend="1368"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a2b2299f61b8f334d925bc2c07bf5f4b7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::randint_like</definition>
        <argsstring>(int64_t high, const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>randint_like</name>
        <param>
          <type>int64_t</type>
          <declname>high</declname>
        </param>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1369" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1369" bodyend="1372"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a8730f5ac7aa10cca4e77c32f99fca7bc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::randn_like</definition>
        <argsstring>(const torch_shape &amp;shape, c10::TensorOptions opt={})</argsstring>
        <name>randn_like</name>
        <param>
          <type>const <ref refid="structquantit_1_1torch__shape" kindref="compound">torch_shape</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>c10::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1373" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1373" bodyend="1376"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a15c2e128ecd55bbc64d9de8ac64d73ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator+</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;B)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1378" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1378" bodyend="1378"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ac2c8f0f3d6470428baa9b0d9180399fb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator-</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;B)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1379" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1379" bodyend="1379"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ad6e64b5114da9b5824bb8916c585732a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator-</definition>
        <argsstring>(const btensor &amp;A)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1380" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1380" bodyend="1380"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a58908a7e27c94bb92a05ea0aad7cb122" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator*</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;B)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1381" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1381" bodyend="1381"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a9d663b876c6643c274f12a37ddd47056" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator*</definition>
        <argsstring>(const btensor &amp;A, const btensor::Scalar &amp;B)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const btensor::Scalar &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1382" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1382" bodyend="1382"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1acbd46de2de106844e0c4949e14678a55" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator*</definition>
        <argsstring>(const btensor::Scalar &amp;B, const btensor &amp;A)</argsstring>
        <name>operator*</name>
        <param>
          <type>const btensor::Scalar &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1383" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1383" bodyend="1383"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a3b36b32f42a0568f6e96a7409367ac08" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator/</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;B)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1384" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1384" bodyend="1384"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a951eafa212c114ccc81ddba70d723173" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator/</definition>
        <argsstring>(const btensor &amp;A, const btensor::Scalar &amp;B)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const btensor::Scalar &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1385" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1385" bodyend="1385"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1afccacfb3ab8fe29211e849302a508ec5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator/</definition>
        <argsstring>(const btensor::Scalar &amp;A, const btensor &amp;B)</argsstring>
        <name>operator/</name>
        <param>
          <type>const btensor::Scalar &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1386" column="9" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1386" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a987badacb7db8e42f6d82644cd14cef3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::sqrt</definition>
        <argsstring>(const btensor &amp;A)</argsstring>
        <name>sqrt</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1388" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1388" bodyend="1388"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ada24304f3415e3734834ae4384f51f4e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::sqrt_</definition>
        <argsstring>(btensor &amp;A)</argsstring>
        <name>sqrt_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1389" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1389" bodyend="1389"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a6d87e76c0b87855a4626f5fe967649ee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::pow</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar p)</argsstring>
        <name>pow</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1390" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1390" bodyend="1390"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7f61fb6ca784bc28b13fb8213f5a20ac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::pow</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;p)</argsstring>
        <name>pow</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1391" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1391" bodyend="1391"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1acc9c0432ddc7c44a6be63f8efa50588c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::pow_</definition>
        <argsstring>(btensor &amp;A, btensor::Scalar p)</argsstring>
        <name>pow_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1392" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1392" bodyend="1392"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a31d8efa0011c25f4f883e094f1ae4131" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::pow_</definition>
        <argsstring>(btensor &amp;A, const btensor &amp;p)</argsstring>
        <name>pow_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1393" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1393" bodyend="1393"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a3400626c2768aaca31ca03a2ffa1eda2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::ge</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>ge</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1395" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1395" bodyend="1395"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a5410b4d2afb5ad3fb34faed8db3e792b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::ge</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>ge</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1396" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1396" bodyend="1396"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1af5f1bacf98630af4cd1b17051956a614" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::le</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>le</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1397" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1397" bodyend="1397"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aa91d8bb3cbec5defd55c33938cfaa429" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::le</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>le</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1398" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1398" bodyend="1398"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aa64283dce32c6641baa39097e10722f5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::less</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>less</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1399" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1399" bodyend="1399"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a955581dc62946d76bfdbad986e41765f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::less</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>less</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1400" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1400" bodyend="1400"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a6daabd19a30574de520d0196edb96533" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::greater</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>greater</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1401" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1401" bodyend="1401"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ab5da2aacf176d94e61b30f8d40f42d9e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::greater</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>greater</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1402" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1402" bodyend="1402"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a2a1db2086f303f2943ad198ed75a3890" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::greater</definition>
        <argsstring>(btensor::Scalar other, const btensor &amp;A)</argsstring>
        <name>greater</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1404" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1404" bodyend="1404"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a2254127f52b6ff244e5be6ca5c0994fb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::less</definition>
        <argsstring>(btensor::Scalar other, const btensor &amp;A)</argsstring>
        <name>less</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1405" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1405" bodyend="1405"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a8dea38075d1280f677d6b21d7904002d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::le</definition>
        <argsstring>(btensor::Scalar other, const btensor &amp;A)</argsstring>
        <name>le</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1406" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1406" bodyend="1406"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1afe741217606f28a63288d0e44a08b217" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::ge</definition>
        <argsstring>(btensor::Scalar other, const btensor &amp;A)</argsstring>
        <name>ge</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1407" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1407" bodyend="1407"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a978ad46fc6f3893227ab5d85874696d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::eq</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;B)</argsstring>
        <name>eq</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1409" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1409" bodyend="1409"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1acd04091ee8311085e2432a18121d77f8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::eq</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar B)</argsstring>
        <name>eq</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1410" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1410" bodyend="1410"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a1267df49aef9baf6d232edaaf3cbecca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::eq</definition>
        <argsstring>(btensor::Scalar B, const btensor &amp;A)</argsstring>
        <name>eq</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1411" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1411" bodyend="1411"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a0d897d918b3a29a1e8fe7524fb8702ab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::not_equal</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;B)</argsstring>
        <name>not_equal</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1412" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1412" bodyend="1412"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7f086e3d1a0b8cef91d6433db18e2be1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::not_equal</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar B)</argsstring>
        <name>not_equal</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1413" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1413" bodyend="1413"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ac706f6329b1ba68a5f719505774f1b44" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::not_equal</definition>
        <argsstring>(btensor::Scalar B, const btensor &amp;A)</argsstring>
        <name>not_equal</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>B</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1414" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1414" bodyend="1414"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a7209645084b45aa662738e7161370397" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&gt;</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1416" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1416" bodyend="1416"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a9818d400de0d2b8eab55d10ce3260d5a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&gt;</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1417" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1417" bodyend="1417"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1af76691b9c34305e950b87a5b8c124e2e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&gt;</definition>
        <argsstring>(btensor::Scalar A, const btensor &amp;other)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1418" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1418" bodyend="1418"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a84677032062bf2a4250da609d4ea86b3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&lt;</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1419" column="8" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1419" bodyend="1419"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a968cf51ba008760e212405c4081b2c69" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&lt;</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1420" column="8" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1420" bodyend="1420"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ac179564bd3a03e4dd8453478edd663cf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&lt;</definition>
        <argsstring>(btensor::Scalar A, const btensor &amp;other)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1421" column="8" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1421" bodyend="1421"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a302e4281cd2d117b206c782fe693206a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&gt;=</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1422" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1422" bodyend="1422"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a22d69fc5080eb4b4ff02e07f6601a185" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&gt;=</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1423" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1423" bodyend="1423"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aae070bfcdd6cfc8b11dc36c288e69658" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&gt;=</definition>
        <argsstring>(btensor::Scalar A, const btensor &amp;other)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1424" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1424" bodyend="1424"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1abb01a36eb037faf917bb7e58408eff5c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&lt;=</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1425" column="8" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1425" bodyend="1425"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a728f2028e826762ca682b1d13b5d82f2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&lt;=</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1426" column="8" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1426" bodyend="1426"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aef3fb14dadae16f1f457affaa6ebc98c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator&lt;=</definition>
        <argsstring>(btensor::Scalar A, const btensor &amp;other)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1427" column="8" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1427" bodyend="1427"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aeb7f716f4af9bf15a0e3a1c06b56e70e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator==</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1428" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1428" bodyend="1428"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1abe442175074cabb4ca74b8c923171bc5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator==</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1429" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1429" bodyend="1429"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ad89e06a0b5bf03b96a7d0a6ebb83bc14" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator==</definition>
        <argsstring>(btensor::Scalar A, const btensor &amp;other)</argsstring>
        <name>operator==</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1430" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1430" bodyend="1430"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ac03f25a204c37806e8a6cae9e238042e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator!=</definition>
        <argsstring>(const btensor &amp;A, btensor::Scalar other)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1431" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1431" bodyend="1431"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ab3f1d9393bd471ccfe66ae6b3e92f09c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator!=</definition>
        <argsstring>(const btensor &amp;A, const btensor &amp;other)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1432" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1432" bodyend="1432"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a897e69799a4fab7a6860598b4bb39a40" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::operator!=</definition>
        <argsstring>(btensor::Scalar A, const btensor &amp;other)</argsstring>
        <name>operator!=</name>
        <param>
          <type>btensor::Scalar</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1433" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1433" bodyend="1433"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a839347b74ef3f6808eabb32c3a55abe9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool quantit::allclose</definition>
        <argsstring>(const btensor &amp;a, const btensor &amp;b, double rtol=1e-5, double atol=1e-8, bool equal_nan=false)</argsstring>
        <name>allclose</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>rtol</declname>
          <defval>1e-5</defval>
        </param>
        <param>
          <type>double</type>
          <declname>atol</declname>
          <defval>1e-8</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>equal_nan</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1435" column="6" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1435" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a1f96eaf468942c27a7c6b604aacb5a21" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::sum</definition>
        <argsstring>(const btensor &amp;t)</argsstring>
        <name>sum</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1437" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1437" bodyend="1437"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a8c0b2b639f3d972b9d9dd6943ccac1cd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::inverse_cvals</definition>
        <argsstring>(const btensor &amp;tens)</argsstring>
        <name>inverse_cvals</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
<para>create a new tensor with its section rule and all its conserved quantities inversed. </para>
        </briefdescription>
        <detaileddescription>
<para>Conserved quantities must be inversed when doing the hermitian conjugation of an operator.</para>
<para>Caution: The blocks of the new tensors are shallow copies of the original.</para>
<para><simplesect kind="return"><para>btensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1452" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1452" bodyend="1452"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a2ec847eec8f106b4d2d47bb0e44b927a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::inverse_cvals</definition>
        <argsstring>(btensor &amp;&amp;tens)</argsstring>
        <name>inverse_cvals</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;&amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1453" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1453" bodyend="1453"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ab0de8ed66af32194aa908140339f1572" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::inverse_cvals</definition>
        <argsstring>(const torch::Tensor &amp;tens)</argsstring>
        <name>inverse_cvals</name>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1454" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1454" bodyend="1454"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aee2c656ac4945142b91eb10ae6e0b16f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::inverse_cvals</definition>
        <argsstring>(torch::Tensor &amp;&amp;tens)</argsstring>
        <name>inverse_cvals</name>
        <param>
          <type>torch::Tensor &amp;&amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1455" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1455" bodyend="1455"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1acec5200effe3b2b788874ae24a4eb7c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::inverse_cvals_</definition>
        <argsstring>(btensor &amp;tens)</argsstring>
        <name>inverse_cvals_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
<para>inverse the selection rule and all the conserved quantities of this btensor. </para>
        </briefdescription>
        <detaileddescription>
<para>Conserved quantities must be inversed when doing the hermitian conjugation of an operator.</para>
<para><simplesect kind="return"><para>btensor&amp; </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1463" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1463" bodyend="1463"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a16e4273a92eac28d204604deb394324b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Tensor &amp;</type>
        <definition>torch::Tensor&amp; quantit::inverse_cvals_</definition>
        <argsstring>(torch::Tensor &amp;tens)</argsstring>
        <name>inverse_cvals_</name>
        <param>
          <type>torch::Tensor &amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1464" column="22" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1464" bodyend="1464"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a30beb3402060342adbcd8d5cbee58ccd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::cval_shift_</definition>
        <argsstring>(btensor &amp;tens, any_quantity_cref shift, int64_t dim)</argsstring>
        <name>cval_shift_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>shift</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
<para>Shifts the conserved quantities of one dimension of the tensor, applies the opposite shift to the conservation rule. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shift</parametername>
</parameternamelist>
<parameterdescription>
<para>shift to apply </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>dimension to which the shift is applied </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1472" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1472" bodyend="1475"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aaf035d10a540e46d4dd0b20da150bdf1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::non_conserving_cval_shift_</definition>
        <argsstring>(btensor &amp;tens, any_quantity_cref shift, int64_t dim)</argsstring>
        <name>non_conserving_cval_shift_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>shift</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
<para>Shifts the conserved quantities of one dimension of the tensor without regards for the conservation laws. </para>
        </briefdescription>
        <detaileddescription>
<para>Can only be applied to empty tensors.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shift</parametername>
</parameternamelist>
<parameterdescription>
<para>shift to apply </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>dimension to which the shift is applied </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1484" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1484" bodyend="1487"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a8996719adfad23e2988b9e7d6b723220" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::shift_selection_rule_</definition>
        <argsstring>(btensor &amp;tens, any_quantity_cref shift)</argsstring>
        <name>shift_selection_rule_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>shift</declname>
        </param>
        <briefdescription>
<para>Modify the selection rule by the value of shift. Can only be done on empty tensors . </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shift</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor&amp; </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1495" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1495" bodyend="1498"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a25c7709de76bf37e7f73826bcf1ee62f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::squeeze</definition>
        <argsstring>(const btensor &amp;tens)</argsstring>
        <name>squeeze</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1500" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1500" bodyend="1500"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ac814d0ed573634c2dd30c845a8926235" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::squeeze</definition>
        <argsstring>(const btensor &amp;tens, int64_t dim)</argsstring>
        <name>squeeze</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1501" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1501" bodyend="1501"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a5f0aa7627560e7b524e20b2338a1b4b0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::squeeze_</definition>
        <argsstring>(btensor &amp;tens)</argsstring>
        <name>squeeze_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1502" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1502" bodyend="1502"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aa93d9cff6adf3773aa7525c36b94dedc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::squeeze_</definition>
        <argsstring>(btensor &amp;tens, int64_t dim)</argsstring>
        <name>squeeze_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1503" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1503" bodyend="1503"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a386e461f3bf8bf5bed979331aca33cf6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::find_selection_rule</definition>
        <argsstring>(const torch::Tensor &amp;tens, const btensor &amp;shape, btensor::Scalar cutoff=0)</argsstring>
        <name>find_selection_rule</name>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>cutoff</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>find the selection rule for rank 2 torch tensors </para>
        </briefdescription>
        <detaileddescription>
<para>throws if no selection rule can be found</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tens</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shape</parametername>
</parameternamelist>
<parameterdescription>
<para>btensor specifying the conserved quantities on each dimensions. its selection rule does not matter. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> selection r </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1514" column="14" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1514" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ab52a4212832069f98cb4b1804cfe1504" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::increment_index_right</definition>
        <argsstring>(btensor::index_list &amp;index, torch::IntArrayRef sizes, size_t rank)</argsstring>
        <name>increment_index_right</name>
        <param>
          <type>btensor::index_list &amp;</type>
          <declname>index</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>sizes</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>rank</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1516" column="6" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1516" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1ae2e335912c5bd18041402fe573ab26bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::increment_index_left</definition>
        <argsstring>(btensor::index_list &amp;index, torch::IntArrayRef max_index, size_t rank)</argsstring>
        <name>increment_index_left</name>
        <param>
          <type>btensor::index_list &amp;</type>
          <declname>index</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>max_index</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>rank</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1517" column="6" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1517" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a2a0576775940a43df5a920534144a2b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::print</definition>
        <argsstring>(const btensor &amp;x)</argsstring>
        <name>print</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1518" column="6" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1518" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1a01d8b94456fd7a4bce7266eda379b4f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string quantit::to_string</definition>
        <argsstring>(const btensor &amp;x)</argsstring>
        <name>to_string</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1519" column="13" declfile="/home/alex/project/quantt/include/blockTensor/btensor.h" declline="1519" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="btensor_8h_1aeae221de41391310df1469bfcfa6372c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
        <definition>btensor&amp; quantit::set_selection_rule_</definition>
        <argsstring>(btensor &amp;tens, any_quantity_cref value)</argsstring>
        <name>set_selection_rule_</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tens</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Set the selection rule of the block tensor. </para>
        </briefdescription>
        <detaileddescription>
<para>Only works on empty btensor.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>btensor&amp; </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="1529" column="16" bodyfile="/home/alex/project/quantt/include/blockTensor/btensor.h" bodystart="1529" bodyend="1529"/>
      </memberdef>
      <memberdef kind="function" id="flat__map_8h_1a49ad8012ae7dbe08519016cf08bcbe3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class key</type>
          </param>
          <param>
            <type>class val</type>
          </param>
          <param>
            <type>class C1</type>
          </param>
          <param>
            <type>class C2</type>
          </param>
          <param>
            <type>class alloc1</type>
          </param>
          <param>
            <type>class alloc2</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>array1</declname>
            <defname>array1</defname>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>array2</declname>
            <defname>array2</defname>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool quantit::operator==</definition>
        <argsstring>(const flat_map&lt; key, val, C1, alloc1, array1 &gt; &amp;a, const flat_map&lt; key, val, C2, alloc2, array2 &gt; &amp;b)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classquantit_1_1flat__map" kindref="compound">flat_map</ref>&lt; key, val, C1, alloc1, array1 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1flat__map" kindref="compound">flat_map</ref>&lt; key, val, C2, alloc2, array2 &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/flat_map.h" line="799" column="6" bodyfile="/home/alex/project/quantt/include/blockTensor/flat_map.h" bodystart="799" bodyend="815"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1a6e68f4f7c897a06536d99a90c4ce5c11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::svd</definition>
        <argsstring>(const btensor &amp;tensor, BOOL some=true, BOOL compute_uv=true)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type><ref refid="structquantit_1_1BOOL" kindref="compound">BOOL</ref></type>
          <declname>some</declname>
          <defval>true</defval>
        </param>
        <param>
          <type><ref refid="structquantit_1_1BOOL" kindref="compound">BOOL</ref></type>
          <declname>compute_uv</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Compute the batched singular value decomposition on the input btensor: <formula id="0">$ I = U.D.V^\dagger $</formula>. Only non-nul elements (the diagonnal) of the diagonnal matrix are returned. </para>
        </briefdescription>
        <detaileddescription>
<para>The matrix decomposition is computed on the last two indices of the tensor, all other indices are treated as indexing otherwise independent matrices. When doing such a decomposition, the conserved value on the batched index act as modification of the selection rule of each individual matrices and the selection rule can be distributed on the output tensors in an arbitrary manner. For the sake of simplicity, the conserved values on the batch indices and the selection rule are all put on the first tensor of the output tuple. The two other tensor have all neutral element on their batch indices and selection rule. Because we reduce the matrix of singular value to a vector of the value, we are force to assign the neutral element on the blocks.</para>
<para>The matrix mulitplication of the diagonnal matrix <formula id="1">$D $</formula>, represented by its list of elements <formula id="2">$d$</formula>, with <formula id="3">$U$</formula> or <formula id="4">$V$</formula> can be done like so: </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="74" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="74" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1afa404bf294467caec7df72b4f605212b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::svd</definition>
        <argsstring>(const btensor &amp;tensor, size_t split)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <briefdescription>
<para>svd for tensor network methods, treat the tensor as a matrix, with the index before the split indices treated as the row of the matrix and the split indice and the ones after and the column indices. </para>
        </briefdescription>
        <detaileddescription>
<para>The original tensor can be reconstructed by tensordot(U.mul(d), V.conj(), {U.dim() - 1}, {V.dim()-1})</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor to decompose </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split</parametername>
</parameternamelist>
<parameterdescription>
<para>seperation between row and columns, among the dimensions of the tensor. rows are [0,split[ and columns are [split,last] </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor,btensor,btensor&gt; U, d and V </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="87" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="87" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1a1a54cb5dbf676032157ef387f0d90421" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::svd</definition>
        <argsstring>(const btensor &amp;tensor, int split)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>split</declname>
        </param>
        <briefdescription>
<para>overload for implicit conversion disambiguation, see svd(const btensor&amp;, size_t) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="92" column="19" bodyfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" bodystart="92" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1ab87543557ea96e84ad3a6251ab632670" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::svd</definition>
        <argsstring>(const btensor &amp;A, size_t split, btensor::Scalar tol, size_t min_size, size_t max_size, btensor::Scalar pow=2)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
<para>truncating svd for tensor network methods, treats the tensor as a matrix, with the index before the split treated as the row of the matrix and the indices at and after the split as the column indices. </para>
        </briefdescription>
        <detaileddescription>
<para>If the number of singular values kept is smaller than max_size an approximation of the original tensor can be reconstructed by tensordot(U.mul(d),V.conj(),{U.dims()-1},{0}) with an error smaller than tol.</para>
<para>At least min_size singular values are kept.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor to decompose </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split</parametername>
</parameternamelist>
<parameterdescription>
<para>index that split the row indices from the column indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>error on the trace of the singular value to the pow that is tolerated </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_size</parametername>
</parameternamelist>
<parameterdescription>
<para>minimum number of singular value kept </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_size</parametername>
</parameternamelist>
<parameterdescription>
<para>maximum number of singular value kept </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pow</parametername>
</parameternamelist>
<parameterdescription>
<para>power used in the computation of the truncation error. When optimizing the energy of a <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref>, 2 is the right choice. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor,btensor,btensor&gt; U,d,V </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="115" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="115" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1a1d4bf9745d1673ac5fc50ca2a817f90a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::svd</definition>
        <argsstring>(const btensor &amp;A, int split, btensor::Scalar tol, size_t min_size, size_t max_size, btensor::Scalar pow=2)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>split</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
<para>overload for implicit conversion disambiguation, see svd(cont btensor&amp;,size_t,btensor::Scalar,size_t,size_t,btensor::Scalar) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="121" column="19" bodyfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" bodystart="121" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1af0a0cdf12fb1c58091afb26d50b4a734" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::svd</definition>
        <argsstring>(const btensor &amp;A, size_t split, btensor::Scalar tol, btensor::Scalar pow=2)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
<para>truncating svd for tensor network methods, treats the tensor as a matrix, with the index before the split treated as the row of the matrix and the indices at and after the split as the column indices. </para>
        </briefdescription>
        <detaileddescription>
<para>An approximation of the original tensor can be reconstructed by tensordot(U.mul(d),V.conj(),{U.dims()-1},{0}) with an error smaller than tol.</para>
<para>At least one singular value is kept.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor to decompose </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split</parametername>
</parameternamelist>
<parameterdescription>
<para>index that split the row indices from the column indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>error on the trace of the singular value to the pow that is tolerated </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pow</parametername>
</parameternamelist>
<parameterdescription>
<para>power used in the computation of the truncation error. When optimizing the energy of a <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref>, 2 is the right choice. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor,btensor,btensor&gt; U,d,V </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="142" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="142" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1af20883a31105eb3b3d0da3bc7a027f2d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::svd</definition>
        <argsstring>(const btensor &amp;A, int split, btensor::Scalar tol, btensor::Scalar pow=2)</argsstring>
        <name>svd</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>split</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
<para>overload for implicit conversion disambiguation, see svd(cont btensor&amp;,size_t,btensor::Scalar,btensor::Scalar) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="146" column="19" bodyfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" bodystart="146" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1a3c1767419a64532c730e8822a9ce55e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor&gt; quantit::eigh</definition>
        <argsstring>(const btensor &amp;tensor, BOOL upper=false)</argsstring>
        <name>eigh</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type><ref refid="structquantit_1_1BOOL" kindref="compound">BOOL</ref></type>
          <declname>upper</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>compute the batched eigenvalue decomposition. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>to solve the eigenvalue problem for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eigenvectors</parametername>
</parameternamelist>
<parameterdescription>
<para>weither to compute the eigenvectors as well </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>upper</parametername>
</parameternamelist>
<parameterdescription>
<para>weither to use only the upper part or only the lower part for the algorithm. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor, btensor&gt; e,S </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="159" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="159" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1abb0d2b984ced912f399237072c29a901" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor&gt; quantit::eigh</definition>
        <argsstring>(const btensor &amp;tensor, size_t split)</argsstring>
        <name>eigh</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <briefdescription>
<para>tensor eigenvalue decomposition </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor to decompose </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split</parametername>
</parameternamelist>
<parameterdescription>
<para>index that split the row indices from the column indices </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor, btensor&gt; e,S </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="167" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="167" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1a6e2e26f42bc2d9e1e8e06ca0d9eab04a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor&gt; quantit::eigh</definition>
        <argsstring>(const btensor &amp;A, size_t split, btensor::Scalar tol, size_t min_size, size_t max_size, btensor::Scalar pow=1)</argsstring>
        <name>eigh</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>truncating tensor eigenvalue decomposition </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor to decompose </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split</parametername>
</parameternamelist>
<parameterdescription>
<para>index that split the row indices from the column indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>tolerence on error induced by truncation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_size</parametername>
</parameternamelist>
<parameterdescription>
<para>minimum number of eigenvalue kept supersede tol </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_size</parametername>
</parameternamelist>
<parameterdescription>
<para>maximum number of eigenvalue kept, supersede tol </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pow</parametername>
</parameternamelist>
<parameterdescription>
<para>power used when computing the induced error <formula id="5">$ sum(e_t^{pow})&lt;tol^{pow}$</formula> where <formula id="6">$e_t$</formula> is a rejected eigenvalues. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor, btensor&gt; </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="180" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="180" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1ad671d05820333f075bfcf37bb365703e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor&gt; quantit::eigh</definition>
        <argsstring>(const btensor &amp;A, size_t split, btensor::Scalar tol, btensor::Scalar pow=1)</argsstring>
        <name>eigh</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>truncating tensor eigenvalue decomposition </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor to decompose </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split</parametername>
</parameternamelist>
<parameterdescription>
<para>index that split the row indices from the column indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>tolerence on error induced by truncation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pow</parametername>
</parameternamelist>
<parameterdescription>
<para>power used when computing the induced error <formula id="5">$ sum(e_t^{pow})&lt;tol^{pow}$</formula> where <formula id="6">$e_t$</formula> is a rejected eigenvalues. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor, btensor&gt; </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="192" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="192" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1adab271693547ba43e7377620ca0490ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; quantit::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, any_quantity_cref qt)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>qt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="236" column="8" bodyfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" bodystart="236" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1a406a4ad5821c9c4e7d7aaf4f618c2777" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string quantit::qformat</definition>
        <argsstring>(any_quantity_cref qt)</argsstring>
        <name>qformat</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>qt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="242" column="13" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="242" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1a062f723271196d5ee3bf59537859ec98" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor&gt; quantit::truncate</definition>
        <argsstring>(btensor &amp;&amp;e, btensor &amp;&amp;S, size_t max, size_t min, btensor::Scalar tol, btensor::Scalar pow)</argsstring>
        <name>truncate</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;&amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;&amp;</type>
          <declname>S</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="244" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="244" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="blockTensor_2LinearAlgebra_8h_1ace015e38c1811d52720029ad899d4bf2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::truncate</definition>
        <argsstring>(btensor &amp;&amp;U, btensor &amp;&amp;d, btensor &amp;&amp;V, size_t max, size_t min, btensor::Scalar tol, btensor::Scalar pow)</argsstring>
        <name>truncate</name>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;&amp;</type>
          <declname>U</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;&amp;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;&amp;</type>
          <declname>V</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>btensor::Scalar</type>
          <declname>pow</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" line="246" column="12" declfile="/home/alex/project/quantt/include/blockTensor/LinearAlgebra.h" declline="246" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1a6b758de38981300ed888f2fc3c3cab0b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t quantit::distance2</definition>
        <argsstring>(any_quantity_cref a, any_quantity_cref b)</argsstring>
        <name>distance2</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>compute the squared &quot;distance&quot; between two conserved quantities. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the euclidian distance, treating each individual conserved quantities within as a distinct vector coordinate.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int64_t squared distance </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="201" column="16" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="201" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1a0329b7c0c87dbe6cfac5ea0b1309ca7d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double quantit::distance</definition>
        <argsstring>(any_quantity_cref a, any_quantity_cref b)</argsstring>
        <name>distance</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>compute the &quot;distance&quot; between two conserved quantities. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the euclidian distance, treating each individual conserved quantities within as a distinct vector coordinate.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int64_t squared distance </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="214" column="15" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="214" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1a443ddf994f2b92ac4f43175ff3a83fc0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(any_quantity &amp;lhs, any_quantity &amp;rhs)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="246" column="13" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="246" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1a5c2c88628f394c9e071228dfefae3763" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(any_quantity_ref lhs, any_quantity_ref rhs)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_ref</ref></type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_ref</ref></type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="247" column="13" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="247" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1a2c718edd525905a3db4960b98840dd1b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator*</definition>
        <argsstring>(any_quantity_cref lhs, any_quantity_cref rhs)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lhs</parametername>
</parameternamelist>
<parameterdescription>
<para>can be a <ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref>,any_quantity_ref or any_quantity_cref </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>can be a <ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref>,any_quantity_ref or any_quantity_cref </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> a new <ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="255" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="255" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1aa14a6a05c15856832407dcc48e650649" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator+</definition>
        <argsstring>(any_quantity_cref lhs, any_quantity_cref rhs)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="261" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="261" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1a7062c0da5518771cd2f1534d0a850ae8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator*</definition>
        <argsstring>(any_quantity_cref lhs, any_quantity &amp;&amp;rhs)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="291" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="291" bodyend="295"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1af7fa4727a14eef3b0e131c67d0893aa9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator+</definition>
        <argsstring>(any_quantity_cref lhs, any_quantity &amp;&amp;rhs)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="296" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="296" bodyend="300"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1ac52770e0c16cc3d6b8d4fb183be3b0eb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator*</definition>
        <argsstring>(any_quantity &amp;&amp;lhs, any_quantity_cref rhs)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="301" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="301" bodyend="305"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1ae3c7c185a1afb6c85f84b726b153ddc7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator+</definition>
        <argsstring>(any_quantity &amp;&amp;lhs, any_quantity_cref rhs)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="306" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="306" bodyend="310"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1a4776dbbe346721661bfe01852ba8dcd9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator*</definition>
        <argsstring>(any_quantity &amp;&amp;lhs, any_quantity &amp;&amp;rhs)</argsstring>
        <name>operator*</name>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="311" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="311" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="cquantity_8h_1aff2d872cd1b55e4b4a83d351f2f8b4d8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref></type>
        <definition>any_quantity quantit::operator+</definition>
        <argsstring>(any_quantity &amp;&amp;lhs, any_quantity &amp;&amp;rhs)</argsstring>
        <name>operator+</name>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity" kindref="compound">any_quantity</ref> &amp;&amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" line="312" column="21" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/cquantity.h" bodystart="312" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="quantity__impl_8h_1a3f6730896c5d328884fe6a238ca04c5d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool quantit::operator==</definition>
        <argsstring>(const vquantity &amp;left, const vquantity &amp;right)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" line="105" column="13" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" bodystart="105" bodyend="105"/>
      </memberdef>
      <memberdef kind="function" id="quantity__impl_8h_1aef9eda13bb8fe700915ce3fa6120f4f7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool quantit::operator!=</definition>
        <argsstring>(const vquantity &amp;left, const vquantity &amp;right)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" line="106" column="13" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" bodystart="106" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="quantity__impl_8h_1a03beb354cd9ce1f0afbd4f55134a35b1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool quantit::operator&lt;</definition>
        <argsstring>(const vquantity &amp;left, const vquantity &amp;right)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" line="107" column="8" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" bodystart="107" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="quantity__impl_8h_1aaed5d42a5fafecc759bdfaeceb2d344f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool quantit::operator&gt;</definition>
        <argsstring>(const vquantity &amp;left, const vquantity &amp;right)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1vquantity" kindref="compound">vquantity</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" line="108" column="13" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/quantity_impl.h" bodystart="108" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="quantity__vector_8h_1a6ac2279dfcdc9d97a0b5f4ec37ff0254" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(any_quantity_vector &amp;a, any_quantity_vector &amp;b)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1any__quantity__vector" kindref="compound">any_quantity_vector</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1any__quantity__vector" kindref="compound">any_quantity_vector</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/Conserved/Composite/quantity_vector.h" line="295" column="13" bodyfile="/home/alex/project/quantt/include/Conserved/Composite/quantity_vector.h" bodystart="295" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="dimension__manip_8h_1a012fae245869384a5114196de9ddd6d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; int64_t &gt;</type>
        <definition>std::vector&lt;int64_t&gt; quantit::concat</definition>
        <argsstring>(std::initializer_list&lt; torch::IntArrayRef &gt; in)</argsstring>
        <name>concat</name>
        <param>
          <type>std::initializer_list&lt; torch::IntArrayRef &gt;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>concatenate into a single list multiple tensor dimension lists. concat({a,b,c},{d,e,f},{g,h,j}) -&gt; {a,b,c,d,e,f,g,h,j} </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dimension_manip.h" line="30" column="13" declfile="/home/alex/project/quantt/include/dimension_manip.h" declline="30" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="dimension__manip_8h_1a709aeacec1e41268c647c00204d6660f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::vector&lt; int64_t &gt;</type>
        <definition>std::vector&lt;int64_t&gt; quantit::concat</definition>
        <argsstring>(Args... args)</argsstring>
        <name>concat</name>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dimension_manip.h" line="32" column="13" bodyfile="/home/alex/project/quantt/include/dimension_manip.h" bodystart="32" bodyend="36"/>
      </memberdef>
      <memberdef kind="function" id="dimension__manip_8h_1a9738744aadba46f255e6b64da2ec4c2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t quantit::prod</definition>
        <argsstring>(torch::IntArrayRef dims, size_t start, size_t n)</argsstring>
        <name>prod</name>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>start</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>compute the product of the dimensions given.</para>
<para>With start and n, compute the product of a slice of the dimensions, using the same rules as torch::IntArrayRef::slice; It compute the product of of the slice spaning the interval [start,n[. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dimension_manip.h" line="46" column="9" declfile="/home/alex/project/quantt/include/dimension_manip.h" declline="46" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="dimension__manip_8h_1a15a83f2ba4ee6d1223819099142f62c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t quantit::prod</definition>
        <argsstring>(torch::IntArrayRef dims)</argsstring>
        <name>prod</name>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dimension_manip.h" line="47" column="9" declfile="/home/alex/project/quantt/include/dimension_manip.h" declline="47" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="dimension__manip_8h_1a2a006bc324880afae56e1775d280ccc5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; int64_t &gt;</type>
        <definition>std::vector&lt;int64_t&gt; quantit::reverse</definition>
        <argsstring>(torch::IntArrayRef dims)</argsstring>
        <name>reverse</name>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reverse the order of the dimension. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dimension_manip.h" line="52" column="13" declfile="/home/alex/project/quantt/include/dimension_manip.h" declline="52" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="dimension__manip_8h_1a0313cfbf96a5935570108117c3fb9628" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::IntArrayRef</type>
        <definition>torch::IntArrayRef quantit::slice</definition>
        <argsstring>(const std::vector&lt; int64_t &gt; &amp;in, size_t start, size_t n)</argsstring>
        <name>slice</name>
        <param>
          <type>const std::vector&lt; int64_t &gt; &amp;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>start</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dimension_manip.h" line="54" column="20" declfile="/home/alex/project/quantt/include/dimension_manip.h" declline="54" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="dimension__manip_8h_1afe6f71fbf776472ed949872eb21e6ef0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::IntArrayRef</type>
        <definition>torch::IntArrayRef quantit::slice</definition>
        <argsstring>(torch::IntArrayRef in, size_t start, size_t n)</argsstring>
        <name>slice</name>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>in</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>start</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dimension_manip.h" line="55" column="20" declfile="/home/alex/project/quantt/include/dimension_manip.h" declline="55" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="dmrg_8h_1aff4090da602b07ab4cee9fe001b511c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::dmrg</definition>
        <argsstring>(MPO &amp;hamiltonian, MPS &amp;in_out_state, const dmrg_options &amp;options, dmrg_logger &amp;logger=dummy_logger)</argsstring>
        <name>dmrg</name>
        <param>
          <type><ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref> &amp;</type>
          <declname>hamiltonian</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>in_out_state</declname>
        </param>
        <param>
          <type>const <ref refid="structquantit_1_1dmrg__options" kindref="compound">dmrg_options</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1dmrg__logger" kindref="compound">dmrg_logger</ref> &amp;</type>
          <declname>logger</declname>
          <defval>dummy_logger</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Apply the DMRG algorithm to solve the ground state of the input hamiltonian given as a <ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref>. Uses the supplied <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> in_out_state as a starting point, and store the optimized <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> there. The associated energy is the return value. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dmrg.h" line="37" column="15" declfile="/home/alex/project/quantt/include/dmrg.h" declline="37" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="dmrg_8h_1a8565556408b3395f5e82825782db68c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::dmrg</definition>
        <argsstring>(bMPO &amp;hamiltonian, bMPS &amp;in_out_state, const dmrg_options &amp;options, dmrg_logger &amp;logger=dummy_logger)</argsstring>
        <name>dmrg</name>
        <param>
          <type><ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>hamiltonian</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>in_out_state</declname>
        </param>
        <param>
          <type>const <ref refid="structquantit_1_1dmrg__options" kindref="compound">dmrg_options</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1dmrg__logger" kindref="compound">dmrg_logger</ref> &amp;</type>
          <declname>logger</declname>
          <defval>dummy_logger</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dmrg.h" line="39" column="9" declfile="/home/alex/project/quantt/include/dmrg.h" declline="39" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="dmrg_8h_1a51d39438e7969759a7d185c539e21b61" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &gt;</type>
        <definition>std::tuple&lt;torch::Tensor, MPS&gt; quantit::dmrg</definition>
        <argsstring>(MPO &amp;hamiltonian, const dmrg_options &amp;options, dmrg_logger &amp;logger=dummy_logger)</argsstring>
        <name>dmrg</name>
        <param>
          <type><ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref> &amp;</type>
          <declname>hamiltonian</declname>
        </param>
        <param>
          <type>const <ref refid="structquantit_1_1dmrg__options" kindref="compound">dmrg_options</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1dmrg__logger" kindref="compound">dmrg_logger</ref> &amp;</type>
          <declname>logger</declname>
          <defval>dummy_logger</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Apply the DMRG algorithm to solve the ground state of the input hamiltonian given as a <ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref>. uses a random starting <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> with minimum_bond bond dimension. return the ground state energy and optimized <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dmrg.h" line="47" column="12" declfile="/home/alex/project/quantt/include/dmrg.h" declline="47" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="dmrg_8h_1a2beeb16a21f31d132c16376b686f3923" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, bMPS&gt; quantit::dmrg</definition>
        <argsstring>(bMPO &amp;hamiltonian, any_quantity_cref state_constraint, const dmrg_options &amp;options, dmrg_logger &amp;logger=dummy_logger)</argsstring>
        <name>dmrg</name>
        <param>
          <type><ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>hamiltonian</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>state_constraint</declname>
        </param>
        <param>
          <type>const <ref refid="structquantit_1_1dmrg__options" kindref="compound">dmrg_options</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1dmrg__logger" kindref="compound">dmrg_logger</ref> &amp;</type>
          <declname>logger</declname>
          <defval>dummy_logger</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/dmrg.h" line="49" column="12" declfile="/home/alex/project/quantt/include/dmrg.h" declline="49" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a3efccae2af6b3102a7f979b0400539ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t quantit::compute_first_index_ascending</definition>
        <argsstring>(torch::Tensor d, torch::Scalar tol, torch::Scalar pow, size_t min_size, size_t max_size)</argsstring>
        <name>compute_first_index_ascending</name>
        <param>
          <type>torch::Tensor</type>
          <declname>d</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <briefdescription>
<para>compute the first kept index such that the sum of of the rejected value to the pow are smaller than tol in an ascending ordered list of values. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>torch tensor ordered by values </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>tolerence on the error induced by the truncation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pow</parametername>
</parameternamelist>
<parameterdescription>
<para>power to use in the computation of the truncation error </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_size</parametername>
</parameternamelist>
<parameterdescription>
<para>minimum size of the output </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_size</parametername>
</parameternamelist>
<parameterdescription>
<para>maximum size of the output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size_t </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="46" column="9" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="46" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a5b8533f8659c1d7cd06951af8c3ee5aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t quantit::compute_last_index</definition>
        <argsstring>(torch::Tensor d, torch::Scalar tol, torch::Scalar pow, size_t min_size, size_t max_size)</argsstring>
        <name>compute_last_index</name>
        <param>
          <type>torch::Tensor</type>
          <declname>d</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <briefdescription>
<para>compute the last kept index such that the sum of of the rejected value to the pow are smaller than tol in a descending ordered list of values. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>torch tensor ordered by values </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>tolerence on the error induced by the truncation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pow</parametername>
</parameternamelist>
<parameterdescription>
<para>power to use in the computation of the truncation error </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_size</parametername>
</parameternamelist>
<parameterdescription>
<para>minimum size of the output </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_size</parametername>
</parameternamelist>
<parameterdescription>
<para>maximum size of the output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size_t </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="60" column="9" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="60" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a1ed9ccef56335f67d7ac8b8d3c5b28ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor,torch::Tensor&gt; quantit::truncate</definition>
        <argsstring>(torch::Tensor u, torch::Tensor d, torch::Tensor v, torch::Scalar tol=0, size_t min_size=1, size_t max_size=-1, torch::Scalar pow=2)</argsstring>
        <name>truncate</name>
        <param>
          <type>torch::Tensor</type>
          <declname>u</declname>
        </param>
        <param>
          <type>torch::Tensor</type>
          <declname>d</declname>
        </param>
        <param>
          <type>torch::Tensor</type>
          <declname>v</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
<para>truncate the input tensors according to the small values of <formula id="7">$ d $</formula>. truncate all the values of <formula id="8">$ d, d_i $</formula>, such that <formula id="9">$ \sum_i abs(d_i)^pow &lt;= tol $</formula>. Assumes the entry of d are ordered in decreasing order. The last dimension of u and v are the one that are truncated along with d. Output is in the same order as input </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="70" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="70" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1ac541b8401a172d40ec008304c3853d8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor,torch::Tensor&gt; quantit::truncate</definition>
        <argsstring>(std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt; &amp;tensors, torch::Scalar tol=0, size_t min_size=1, size_t max_size=-1, torch::Scalar pow=2)</argsstring>
        <name>truncate</name>
        <param>
          <type>std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt; &amp;</type>
          <declname>tensors</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="71" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="71" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a84cc59507c3c4a2321d9612dc166b196" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::truncate</definition>
        <argsstring>(torch::Tensor u, torch::Tensor e, torch::Scalar tol=0, size_t min_size=1, size_t max_size=-1, torch::Scalar pow=1)</argsstring>
        <name>truncate</name>
        <param>
          <type>torch::Tensor</type>
          <declname>u</declname>
        </param>
        <param>
          <type>torch::Tensor</type>
          <declname>e</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>truncate the input tensors according to the small values of e. truncate all the values of <formula id="10">$ e, e_i $</formula>, such that <formula id="11">$ \sum_i abs(e_i)^pow &lt;= tol $</formula>. Assumes the entry of e are ordered in decreasing order. The last dimension of u is the one that is truncated along with e. Output is in the same order as input </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="80" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="80" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1ab72e61e1b89ab121387b511226160103" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::truncate</definition>
        <argsstring>(std::tuple&lt; torch::Tensor, torch::Tensor &gt; &amp;tensors, torch::Scalar tol=0, size_t min_size=1, size_t max_size=-1, torch::Scalar pow=1)</argsstring>
        <name>truncate</name>
        <param>
          <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt; &amp;</type>
          <declname>tensors</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>truncate the tensors in the tuple according to the values in the second element. </para>
        </briefdescription>
        <detaileddescription>
<para>Assume the seconds tensors value are ordered from maximum to minimum. truncate all the values of <formula id="12">$ e_i $</formula>, such that <formula id="11">$ \sum_i abs(e_i)^pow &lt;= tol $</formula>. where the <formula id="12">$ e_i $</formula> are the values of the second tensor</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensors</parametername>
</parameternamelist>
<parameterdescription>
<para>tuple of tensors, the second is a diagonnal matrix </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>maximal truncation error </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_size</parametername>
</parameternamelist>
<parameterdescription>
<para>minimum size of the output </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_size</parametername>
</parameternamelist>
<parameterdescription>
<para>maximum size of the output </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pow</parametername>
</parameternamelist>
<parameterdescription>
<para>power in the computation of the truncation error </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;torch::Tensor,torch::Tensor&gt; </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="95" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="95" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a38b9c632faf80f76aa4d135640239857" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor,torch::Tensor&gt; quantit::svd</definition>
        <argsstring>(torch::Tensor A, size_t split, torch::Scalar tol, size_t min_size, size_t max_size, torch::Scalar pow=2)</argsstring>
        <name>svd</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>perform the singular value decomposition of the rank N tensor A. The tensor A is implicitly reshape as a matrix: all the index [0,split] become the left index and ]split,N] is the right index. This behavior is different from the batching done by pytorch&apos;s functions. can additionnaly truncate the output tensors, if tol != 0. Consult truncate for mor details. output U,D,V such that A = U*diag(D)*V^T </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="104" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="104" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1ab33adedef296c4278e738f7d2cda5cab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor,torch::Tensor&gt; quantit::svd</definition>
        <argsstring>(torch::Tensor A, size_t split, torch::Scalar tol, torch::Scalar pow=2)</argsstring>
        <name>svd</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="105" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="105" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a728300a8e4bd02c4f8f0633bb3d98f68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor,torch::Tensor&gt; quantit::svd</definition>
        <argsstring>(torch::Tensor A, size_t split)</argsstring>
        <name>svd</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="106" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="106" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a45ebae0c95d867915882b62fb75d12d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor,torch::Tensor&gt; quantit::svd</definition>
        <argsstring>(torch::Tensor A, int split)</argsstring>
        <name>svd</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>split</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="107" column="19" bodyfile="/home/alex/project/quantt/include/LinearAlgebra.h" bodystart="107" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a8ad3cded7142f990fecda10dff20200a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eig</definition>
        <argsstring>(torch::Tensor A, size_t split)</argsstring>
        <name>eig</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="109" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="109" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1aac6bb007a7639f064745a674a04e96a3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eig</definition>
        <argsstring>(torch::Tensor A, int split)</argsstring>
        <name>eig</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>split</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="110" column="19" bodyfile="/home/alex/project/quantt/include/LinearAlgebra.h" bodystart="110" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1a4114d295cfc5f819b93c5c20f35818db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eig</definition>
        <argsstring>(torch::Tensor A, size_t split, torch::Scalar tol, torch::Scalar pow=1)</argsstring>
        <name>eig</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="111" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="111" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1ae39d294c82e6208649bac6a6d24a3b5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eig</definition>
        <argsstring>(torch::Tensor A, size_t split, torch::Scalar tol, size_t min_size, size_t max_size, torch::Scalar pow=1)</argsstring>
        <name>eig</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="112" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="112" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1ad8c1431835ee7d74624e3918935f326b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eigh</definition>
        <argsstring>(torch::Tensor A, size_t split)</argsstring>
        <name>eigh</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="114" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="114" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1ae06f51328f5769f6e441fbbc6fba64ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eigh</definition>
        <argsstring>(torch::Tensor A, int split)</argsstring>
        <name>eigh</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>int</type>
          <declname>split</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="115" column="19" bodyfile="/home/alex/project/quantt/include/LinearAlgebra.h" bodystart="115" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1aaf003bf108b51b4314d9386e28197187" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eigh</definition>
        <argsstring>(torch::Tensor A, size_t split, torch::Scalar tol, torch::Scalar pow=1)</argsstring>
        <name>eigh</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="116" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="116" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="LinearAlgebra_8h_1acfe9fcf1702797f520a817dac011ed26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; torch::Tensor, torch::Tensor &gt;</type>
        <definition>std::tuple&lt;torch::Tensor,torch::Tensor&gt; quantit::eigh</definition>
        <argsstring>(torch::Tensor A, size_t split, torch::Scalar tol, size_t min_size, size_t max_size, torch::Scalar pow=1)</argsstring>
        <name>eigh</name>
        <param>
          <type>torch::Tensor</type>
          <declname>A</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>split</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>min_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>pow</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/LinearAlgebra.h" line="117" column="12" declfile="/home/alex/project/quantt/include/LinearAlgebra.h" declline="117" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="models_8h_1a45f300f4aa8ccb2a91d323282ca3f128" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref></type>
        <definition>MPO quantit::Heisenberg</definition>
        <argsstring>(torch::Tensor J, size_t lenght)</argsstring>
        <name>Heisenberg</name>
        <param>
          <type>torch::Tensor</type>
          <declname>J</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>lenght</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generate the hamiltonian for the Heisenberg model. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/models.h" line="27" column="5" declfile="/home/alex/project/quantt/include/models.h" declline="27" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="models_8h_1af9909c827c110c886c6cd0f497a4345e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref></type>
        <definition>bMPO quantit::Heisenberg</definition>
        <argsstring>(torch::Tensor J, size_t lenght, const btensor &amp;local_shape)</argsstring>
        <name>Heisenberg</name>
        <param>
          <type>torch::Tensor</type>
          <declname>J</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>lenght</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>local_shape</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/models.h" line="28" column="6" declfile="/home/alex/project/quantt/include/models.h" declline="28" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="models_8h_1a6f045f3f1c688d770b6707a5f88cd4af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref></type>
        <definition>MPO quantit::Hubbard</definition>
        <argsstring>(torch::Tensor U, torch::Tensor mu, size_t lenght)</argsstring>
        <name>Hubbard</name>
        <param>
          <type>torch::Tensor</type>
          <declname>U</declname>
        </param>
        <param>
          <type>torch::Tensor</type>
          <declname>mu</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>lenght</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generate the Hamiltonian for the first neighbor 1D Hubbard model. The enrgy scale is defined by the first neighbor hopping t=1. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/models.h" line="37" column="5" declfile="/home/alex/project/quantt/include/models.h" declline="37" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="models_8h_1a7a70556bf769cba41861c5f06a8ead18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref></type>
        <definition>bMPO quantit::Hubbard</definition>
        <argsstring>(torch::Tensor U, torch::Tensor mu, size_t lenght, const btensor &amp;local_shape)</argsstring>
        <name>Hubbard</name>
        <param>
          <type>torch::Tensor</type>
          <declname>U</declname>
        </param>
        <param>
          <type>torch::Tensor</type>
          <declname>mu</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>lenght</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>local_shape</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/models.h" line="38" column="6" declfile="/home/alex/project/quantt/include/models.h" declline="38" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1adeb4bc6a1439934a96ccbc171bbb60f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref></type>
        <definition>MPS quantit::random_MPS</definition>
        <argsstring>(size_t length, size_t bond_dim, size_t phys_dim, torch::TensorOptions opt={})</argsstring>
        <name>random_MPS</name>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>phys_dim</declname>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="43" column="5" declfile="/home/alex/project/quantt/include/MPT.h" declline="43" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1aa1a1e87c681a8cdc1c25269da182de94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref></type>
        <definition>MPS quantit::random_MPS</definition>
        <argsstring>(size_t bond_dim, const MPO &amp;hamil, torch::TensorOptions opt={})</argsstring>
        <name>random_MPS</name>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref> &amp;</type>
          <declname>hamil</declname>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="44" column="5" declfile="/home/alex/project/quantt/include/MPT.h" declline="44" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a6dbbaacf3821232a946afb35f81f7bea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref></type>
        <definition>MPS quantit::random_MPS</definition>
        <argsstring>(size_t bond_dim, const std::vector&lt; int64_t &gt; &amp;phys_dims, torch::TensorOptions opt={})</argsstring>
        <name>random_MPS</name>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const std::vector&lt; int64_t &gt; &amp;</type>
          <declname>phys_dims</declname>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="45" column="5" declfile="/home/alex/project/quantt/include/MPT.h" declline="45" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1afc889b85f905e377602128ca20681867" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref></type>
        <definition>bMPS quantit::random_bMPS</definition>
        <argsstring>(size_t length, size_t bond_dim, const btensor &amp;phys_dim_spec, any_quantity_cref q_num, unsigned int seed=(std::random_device())(), torch::TensorOptions opt={})</argsstring>
        <name>random_bMPS</name>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>phys_dim_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>q_num</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>seed</declname>
          <defval>(std::random_device())()</defval>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="49" column="6" declfile="/home/alex/project/quantt/include/MPT.h" declline="49" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1abd25a0767945ab7c73e708714b477289" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref></type>
        <definition>bMPS quantit::random_bMPS</definition>
        <argsstring>(size_t bond_dim, const bMPO &amp;Hamil, any_quantity_cref q_num, unsigned int seed=(std::random_device())(), torch::TensorOptions opt={})</argsstring>
        <name>random_bMPS</name>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>Hamil</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>q_num</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>seed</declname>
          <defval>(std::random_device())()</defval>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="51" column="6" declfile="/home/alex/project/quantt/include/MPT.h" declline="51" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1ada0e4305ba63552a1440bff4548c0c4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref></type>
        <definition>bMPS quantit::random_bMPS</definition>
        <argsstring>(size_t bond_dim, const std::vector&lt; btensor &gt; &amp;phys_dim_spec, any_quantity_cref q_num, unsigned int seed=(std::random_device())(), torch::TensorOptions opt={})</argsstring>
        <name>random_bMPS</name>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt; &amp;</type>
          <declname>phys_dim_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>q_num</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>seed</declname>
          <defval>(std::random_device())()</defval>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="53" column="6" declfile="/home/alex/project/quantt/include/MPT.h" declline="53" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1aaaeaf01a878eb81aab7e45e612717466" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref></type>
        <definition>bMPS quantit::random_MPS</definition>
        <argsstring>(size_t length, size_t bond_dim, const btensor &amp;phys_dim_spec, any_quantity_cref q_num, unsigned int seed=(std::random_device())(), torch::TensorOptions opt={})</argsstring>
        <name>random_MPS</name>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>phys_dim_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>q_num</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>seed</declname>
          <defval>(std::random_device())()</defval>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="55" column="6" declfile="/home/alex/project/quantt/include/MPT.h" declline="55" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a30f89ec6ada6384c8256a5b2ee3d92ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref></type>
        <definition>bMPS quantit::random_MPS</definition>
        <argsstring>(size_t bond_dim, const bMPO &amp;Hamil, any_quantity_cref q_num, unsigned int seed=(std::random_device())(), torch::TensorOptions opt={})</argsstring>
        <name>random_MPS</name>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>Hamil</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>q_num</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>seed</declname>
          <defval>(std::random_device())()</defval>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="57" column="6" declfile="/home/alex/project/quantt/include/MPT.h" declline="57" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a1594ade3059ef8a7dc581d056698aaae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref></type>
        <definition>bMPS quantit::random_MPS</definition>
        <argsstring>(size_t bond_dim, const std::vector&lt; btensor &gt; &amp;phys_dim_spec, any_quantity_cref q_num, unsigned int seed=(std::random_device())(), torch::TensorOptions opt={})</argsstring>
        <name>random_MPS</name>
        <param>
          <type>size_t</type>
          <declname>bond_dim</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt; &amp;</type>
          <declname>phys_dim_spec</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1vquantity" kindref="compound">any_quantity_cref</ref></type>
          <declname>q_num</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>seed</declname>
          <defval>(std::random_device())()</defval>
        </param>
        <param>
          <type>torch::TensorOptions</type>
          <declname>opt</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="59" column="6" declfile="/home/alex/project/quantt/include/MPT.h" declline="59" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a404d45dac5593f553eac5694eb5afa39" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(MPS &amp;lhs, MPS &amp;rhs)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="404" column="13" bodyfile="/home/alex/project/quantt/include/MPT.h" bodystart="404" bodyend="404"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1ad05d95a578aad8b4a3a5680a66658e9a" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(MPO &amp;lhs, MPO &amp;rhs) noexcept</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="484" column="13" bodyfile="/home/alex/project/quantt/include/MPT.h" bodystart="484" bodyend="484"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a14b3fde4ea9788e1020c905c06ecd4ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(bMPS &amp;lhs, bMPS &amp;rhs)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="617" column="13" bodyfile="/home/alex/project/quantt/include/MPT.h" bodystart="617" bodyend="617"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a141b54e49bd7be695f33307d22afd5d8" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::swap</definition>
        <argsstring>(bMPO &amp;lhs, bMPO &amp;rhs) noexcept</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="698" column="13" bodyfile="/home/alex/project/quantt/include/MPT.h" bodystart="698" bodyend="698"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1af198bf2c11eb43eb438d50b076bc012f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::contract</definition>
        <argsstring>(const bMPS &amp;a, const bMPS &amp;b, const bMPO &amp;obs)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>obs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="700" column="9" declfile="/home/alex/project/quantt/include/MPT.h" declline="700" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1aa981fbbbb8d6404f11c29fa45aa25831" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::contract</definition>
        <argsstring>(const bMPS &amp;a, const bMPS &amp;b, const bMPO &amp;obs, btensor left_edge, const btensor &amp;right_edge)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPO" kindref="compound">bMPO</ref> &amp;</type>
          <declname>obs</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
          <declname>left_edge</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>right_edge</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="701" column="9" declfile="/home/alex/project/quantt/include/MPT.h" declline="701" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1acc3fe85f64776fc11c61cf015ae7fedb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Z</type>
            <defval>std::enable_if_t&lt;std::is_base_of_v&lt;vector_lift&lt;T, typename T::Tens&gt;, T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void quantit::print_dims</definition>
        <argsstring>(const T &amp;mps)</argsstring>
        <name>print_dims</name>
        <param>
          <type>const T &amp;</type>
          <declname>mps</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="705" column="6" bodyfile="/home/alex/project/quantt/include/MPT.h" bodystart="705" bodyend="713"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a5dc421151f72e5eedd038461fd4bc3a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::contract</definition>
        <argsstring>(const MPS &amp;a, const MPS &amp;b, const MPO &amp;obs, torch::Tensor left_edge, const torch::Tensor &amp;right_edge)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref> &amp;</type>
          <declname>obs</declname>
        </param>
        <param>
          <type>torch::Tensor</type>
          <declname>left_edge</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>right_edge</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="715" column="15" declfile="/home/alex/project/quantt/include/MPT.h" declline="715" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1aa298790602927868ed055d7aac31d4d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::contract</definition>
        <argsstring>(const MPS &amp;a, const MPS &amp;b, const MPO &amp;obs)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1MPO" kindref="compound">MPO</ref> &amp;</type>
          <declname>obs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="717" column="15" declfile="/home/alex/project/quantt/include/MPT.h" declline="717" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a0427c1c749ff733444fa54421081a961" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::contract</definition>
        <argsstring>(const MPS &amp;a, const MPS &amp;b)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="718" column="15" declfile="/home/alex/project/quantt/include/MPT.h" declline="718" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a196dd118322b13d486fa3f83579e7f75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::contract</definition>
        <argsstring>(const MPS &amp;a, const MPS &amp;b, torch::Tensor left_edge, const torch::Tensor &amp;right_edge)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1MPS" kindref="compound">MPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>torch::Tensor</type>
          <declname>left_edge</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>right_edge</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="719" column="15" declfile="/home/alex/project/quantt/include/MPT.h" declline="719" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1a92df8f437066f8d82e38b9b1c0b467d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::contract</definition>
        <argsstring>(const bMPS &amp;a, const bMPS &amp;b, btensor left_edge, const btensor &amp;right_edge)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
          <declname>left_edge</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>right_edge</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="723" column="9" declfile="/home/alex/project/quantt/include/MPT.h" declline="723" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="MPT_8h_1ab8119782dd7276071db1a70450c32030" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref></type>
        <definition>btensor quantit::contract</definition>
        <argsstring>(const bMPS &amp;a, const bMPS &amp;b)</argsstring>
        <name>contract</name>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classquantit_1_1bMPS" kindref="compound">bMPS</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/MPT.h" line="724" column="9" declfile="/home/alex/project/quantt/include/MPT.h" declline="724" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="numeric_8h_1a231636d096dbb7cbe8102ca8a7453756" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::Scalar</type>
        <definition>torch::Scalar quantit::eps</definition>
        <argsstring>(torch::ScalarType intype)</argsstring>
        <name>eps</name>
        <param>
          <type>torch::ScalarType</type>
          <declname>intype</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/numeric.h" line="77" column="22" bodyfile="/home/alex/project/quantt/include/numeric.h" bodystart="77" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="numeric_8h_1a4f80806913809722f1758008ce8b82e4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>torch::ScalarType</type>
        <definition>torch::ScalarType quantit::real_type</definition>
        <argsstring>(torch::ScalarType intype)</argsstring>
        <name>real_type</name>
        <param>
          <type>torch::ScalarType</type>
          <declname>intype</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/numeric.h" line="92" column="26" bodyfile="/home/alex/project/quantt/include/numeric.h" bodystart="92" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="operators_8h_1ae9d8a7d4f1ab65f1f622a8881eba591d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; tens, tens, tens, tens &gt;</type>
        <definition>std::tuple&lt;tens, tens, tens, tens&gt; quantit::fermions</definition>
        <argsstring>()</argsstring>
        <name>fermions</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>generate the set of operator for spins 1/2 fermions. return them in this order: c_up,c_dn,F,id where c_up is the up spin fermion annihilation operator, c_dn is the down spin fermion annihilation operator, F is the fermion phase operator (necessary for non local anti-commutations) and id is the identity matrix. The creation operator are obtained by taking the hermitian conjugate of the annihilation operators. All those operators are 4x4 matrices. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/operators.h" line="39" column="12" declfile="/home/alex/project/quantt/include/operators.h" declline="39" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="operators_8h_1a3e207a62517e5f06397f290ddf5c2738" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor, btensor&gt; quantit::fermions</definition>
        <argsstring>(const btensor &amp;shape)</argsstring>
        <name>fermions</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/operators.h" line="41" column="12" declfile="/home/alex/project/quantt/include/operators.h" declline="41" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="operators_8h_1a946109b32b9dba1adb72c53bcfd1dc5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; tens, tens, tens, tens, tens &gt;</type>
        <definition>std::tuple&lt;tens, tens, tens, tens, tens&gt; quantit::pauli</definition>
        <argsstring>()</argsstring>
        <name>pauli</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generate the set of Pauli matrices, proportionnal to spin 1/2 spin operator. return them in this order: Sx,iSy,Sz,lo,id where Sx is the x Pauli matrix, iSy is the y Pauli matrix multiplied with the imaginary unity, Sz is the z Pauli matrix. lo is the lowering operator: it reduce the spin by 1. if the spin is already -1/2 it destroy the state. the raising operator is lo&apos;s hermitian conjugate. id is the identity matrix. All those operators are 2x2 matrices. iSy is given instead of Sy to avoid unnecarily introducing complex number. Time reversible model can be written in term of iSy without any complex numbers. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/operators.h" line="54" column="12" declfile="/home/alex/project/quantt/include/operators.h" declline="54" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="operators_8h_1a676871345efcff15a0cab16fa7e7d5c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref>, <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &gt;</type>
        <definition>std::tuple&lt;btensor, btensor, btensor&gt; quantit::pauli</definition>
        <argsstring>(const btensor &amp;shape)</argsstring>
        <name>pauli</name>
        <param>
          <type>const <ref refid="classquantit_1_1btensor" kindref="compound">btensor</ref> &amp;</type>
          <declname>shape</declname>
        </param>
        <briefdescription>
<para>return generator for the pauli matrices Sx and Sy cannot be returned because they do not have a well defined quantum number. To make use of conservation rule with Heisenberg, Ising and other spin models, it must be done in terms of the lower/raising operator and Sz. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shape</parametername>
</parameternamelist>
<parameterdescription>
<para>A btensor specifying the conserved quantities of the bra an ket sides of the operators. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple&lt;btensor,btensor,btensor&gt; lowering operator, Sz, identity </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/operators.h" line="62" column="12" declfile="/home/alex/project/quantt/include/operators.h" declline="62" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="templateMeta_8h_1a30efbcfedd8356cbce70b22085166424" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple1</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>constexpr decltype(auto)</type>
        <definition>constexpr decltype(auto) quantit::for_each</definition>
        <argsstring>(Tuple1 &amp;&amp;T1, F &amp;&amp;f)</argsstring>
        <name>for_each</name>
        <param>
          <type>Tuple1 &amp;&amp;</type>
          <declname>T1</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>for each elements in a tuple </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple1</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the function to apply </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>T1</parametername>
</parameternamelist>
<parameterdescription>
<para>a tuple type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>function to apply to each </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr decltype(auto) tuple of the results </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="121" column="20" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="121" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="templateMeta_8h_1a4028aac6fcd0d659f37053f9dd2d6ce6" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple1</type>
          </param>
          <param>
            <type>class Tuple2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>constexpr decltype(auto)</type>
        <definition>constexpr decltype(auto) quantit::for_each2</definition>
        <argsstring>(Tuple1 &amp;&amp;T1, Tuple2 &amp;&amp;T2, F &amp;&amp;f)</argsstring>
        <name>for_each2</name>
        <param>
          <type>Tuple1 &amp;&amp;</type>
          <declname>T1</declname>
        </param>
        <param>
          <type>Tuple2 &amp;&amp;</type>
          <declname>T2</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>for each element in a couple of tuple </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple1</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple2</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>T1</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the first tuple </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T2</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the second tuple </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>function to apply to the elements of the pair of tuple </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr decltype(auto) tuple of the result of the function </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/templateMeta.h" line="149" column="20" bodyfile="/home/alex/project/quantt/include/templateMeta.h" bodystart="149" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="tensorgdot_8h_1ab21092fe64be866344b80040519f426d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor</type>
        <definition>torch::Tensor quantit::tensorgdot</definition>
        <argsstring>(const torch::Tensor &amp;add, const torch::Tensor &amp;mul1, const torch::Tensor &amp;mul2, torch::IntArrayRef dims1, torch::IntArrayRef dims2, torch::Scalar beta=1, torch::Scalar alpha=1)</argsstring>
        <name>tensorgdot</name>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>add</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>mul1</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>mul2</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims1</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims2</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>beta</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>alpha</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>generalized tensordot, performs <formula id="13">$ D_{ij...klm} = alpha*C_{ij...klm} + beta*\sum_{...klm} A_{ij...klm}*B_{ij...klm} $</formula> Like tensordot is the equivalent of the matrix mutiplcation for tensors, this routine is the equivalent of the generalized matrix multiplication for tensor (torch::addmm). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>add</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor C </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul1</parametername>
</parameternamelist>
<parameterdescription>
<para>input tensor A </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul2</parametername>
</parameternamelist>
<parameterdescription>
<para>input tensor B </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims1</parametername>
</parameternamelist>
<parameterdescription>
<para>list of dimensions of input1 to be summed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims2</parametername>
</parameternamelist>
<parameterdescription>
<para>list of dimension of input2 to be summed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient to mulitply the result of the dot product with. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient to scale the input tensor </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>torch::Tensor The output tensor D </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/tensorgdot.h" line="34" column="15" declfile="/home/alex/project/quantt/include/tensorgdot.h" declline="34" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="tensorgdot_8h_1a9a881c5458aaa6164e61b2d3c85a221f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor &amp;</type>
        <definition>torch::Tensor&amp; quantit::tensorgdot_</definition>
        <argsstring>(torch::Tensor &amp;output, const torch::Tensor &amp;mul1, const torch::Tensor &amp;mul2, torch::IntArrayRef dims1, torch::IntArrayRef dims2, torch::Scalar beta=1, torch::Scalar alpha=1)</argsstring>
        <name>tensorgdot_</name>
        <param>
          <type>torch::Tensor &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>mul1</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>mul2</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims1</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims2</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>beta</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>alpha</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>generalized tensordot, performs <formula id="14">$ C_{ij...klm} = alpha*C_{ij...klm} + beta*\sum_{...klm} A_{ij...klm}*B_{ij...klm} ­$</formula> Like tensordot is the equivalent of the matrix mutiplcation for tensors, this routine is the equivalent of the generalized matrix multiplication for tensor (torch::addmm). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>the input tensor C, and the output tensor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul1</parametername>
</parameternamelist>
<parameterdescription>
<para>input tensor A </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul2</parametername>
</parameternamelist>
<parameterdescription>
<para>input tensor B </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims1</parametername>
</parameternamelist>
<parameterdescription>
<para>list of dimensions of input1 to be summed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims2</parametername>
</parameternamelist>
<parameterdescription>
<para>list of dimension of input2 to be summed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient to mulitply the result of the dot product with. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient to scale the input tensor </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>torch::Tensor&amp; refrence to the output tensor </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/tensorgdot.h" line="51" column="15" declfile="/home/alex/project/quantt/include/tensorgdot.h" declline="51" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="tensorgdot_8h_1a3ea38d1b5a01dd417ccac62f15889ef9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor &amp;</type>
        <definition>torch::Tensor&amp; quantit::tensorgdot_out</definition>
        <argsstring>(torch::Tensor &amp;output, const torch::Tensor &amp;add, const torch::Tensor &amp;mul1, const torch::Tensor &amp;mul2, torch::IntArrayRef dims1, torch::IntArrayRef dims2, torch::Scalar beta=1, torch::Scalar alpha=1)</argsstring>
        <name>tensorgdot_out</name>
        <param>
          <type>torch::Tensor &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>add</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>mul1</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>mul2</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims1</declname>
        </param>
        <param>
          <type>torch::IntArrayRef</type>
          <declname>dims2</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>beta</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>alpha</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>generalized tensordot, performs <formula id="13">$ D_{ij...klm} = alpha*C_{ij...klm} + beta*\sum_{...klm} A_{ij...klm}*B_{ij...klm} $</formula> Like tensordot is the equivalent of the matrix mutiplcation for tensors, this routine is the equivalent of the generalized matrix multiplication for tensor (torch::addmm). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>the output tensor D </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>add</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor C </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul1</parametername>
</parameternamelist>
<parameterdescription>
<para>input tensor A </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mul2</parametername>
</parameternamelist>
<parameterdescription>
<para>input tensor B </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims1</parametername>
</parameternamelist>
<parameterdescription>
<para>list of dimensions of input1 to be summed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims2</parametername>
</parameternamelist>
<parameterdescription>
<para>list of dimension of input2 to be summed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient to mulitply the result of the dot product with. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient to scale the input tensor </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>torch::Tensor&amp; Reference to the output tensor D </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/tensorgdot.h" line="69" column="15" declfile="/home/alex/project/quantt/include/tensorgdot.h" declline="69" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="tensorgdot_8h_1a975907079401bbe33d06f29db319b477" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch::Tensor &amp;</type>
        <definition>torch::Tensor&amp; quantit::tensorgdot_</definition>
        <argsstring>(torch::Tensor &amp;output, const torch::Tensor &amp;input1, const torch::Tensor &amp;input2, int dims, torch::Scalar beta=1, torch::Scalar alpha=1)</argsstring>
        <name>tensorgdot_</name>
        <param>
          <type>torch::Tensor &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>input1</declname>
        </param>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>input2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dims</declname>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>beta</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>torch::Scalar</type>
          <declname>alpha</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>generalized tensordot, performs <formula id="15">$ C_{ij...klm} = alpha*C_{ij...klm} + beta*\sum_{...klm} A_{ij...klm}*B_{ij...klm} $</formula> Like tensordot is the equivalent of the matrix mutiplcation for tensors, this routine is the equivalent of the generalized matrix multiplication for tensor (torch::addmm). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>output tensor C, result of the contraction is added to it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>input1</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor A </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>input2</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor B </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dims</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of dimensions to contract </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient for the addition </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar coefficient for the addition </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>torch::Tensor&amp; reference to the output tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/tensorgdot.h" line="84" column="15" declfile="/home/alex/project/quantt/include/tensorgdot.h" declline="84" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="torch__formatter_8h_1a15362a368143a27ab57192bea36405d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void quantit::print</definition>
        <argsstring>(const torch::Tensor &amp;X)</argsstring>
        <name>print</name>
        <param>
          <type>const torch::Tensor &amp;</type>
          <declname>X</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/alex/project/quantt/include/torch_formatter.h" line="23" column="6" declfile="/home/alex/project/quantt/include/torch_formatter.h" declline="23" declcolumn="6"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/alex/project/quantt/include/blockTensor/btensor.h" line="37" column="1"/>
  </compounddef>
</doxygen>
