\hypertarget{flat__map_8h_source}{}\doxysection{flat\+\_\+map.\+h}
\label{flat__map_8h_source}\index{/Users/alex/Documents/Prog/QuantiT/include/blockTensor/flat\_map.h@{/Users/alex/Documents/Prog/QuantiT/include/blockTensor/flat\_map.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ * File: flat\_map.h}}
\DoxyCodeLine{3 \textcolor{comment}{ * Project: QuantiT}}
\DoxyCodeLine{4 \textcolor{comment}{ * File Created: Thursday, 15th October 2020 1:03:53 pm}}
\DoxyCodeLine{5 \textcolor{comment}{ * Author: Alexandre Foley (Alexandre.foley@usherbrooke.ca)}}
\DoxyCodeLine{6 \textcolor{comment}{ * -\/-\/-\/-\/-\/}}
\DoxyCodeLine{7 \textcolor{comment}{ * Last Modified: Thursday, 15th October 2020 1:03:53 pm}}
\DoxyCodeLine{8 \textcolor{comment}{ * Modified By: Alexandre Foley (Alexandre.foley@usherbrooke.ca>)}}
\DoxyCodeLine{9 \textcolor{comment}{ * -\/-\/-\/-\/-\/}}
\DoxyCodeLine{10 \textcolor{comment}{ * Copyright (c) 2020 Alexandre Foley}}
\DoxyCodeLine{11 \textcolor{comment}{ * Licensed under GPL v3}}
\DoxyCodeLine{12 \textcolor{comment}{ */}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef D7E9786D\_BD4E\_41BF\_A6C5\_4E902E127A7D}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define D7E9786D\_BD4E\_41BF\_A6C5\_4E902E127A7D}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}doctest/doctest\_proxy.h"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <boost/stl\_interfaces/iterator\_interface.hpp>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <fmt/core.h>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <fmt/ranges.h>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <numeric>}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{namespace }quantit}
\DoxyCodeLine{30 \{}
\DoxyCodeLine{31 \textcolor{keyword}{template} <\textcolor{keyword}{class} Key, \textcolor{keyword}{class} Value, \textcolor{keyword}{class} Comp\_less = std::less<Key>,}
\DoxyCodeLine{32           \textcolor{keyword}{class} Allocator = std::allocator<std::pair<Key, Value>>, \textcolor{keyword}{template} <\textcolor{keyword}{class}...> \textcolor{keyword}{class }Array = std::vector>}
\DoxyCodeLine{33 \textcolor{keyword}{class }\mbox{\hyperlink{classquantit_1_1flat__map}{flat\_map}}}
\DoxyCodeLine{34 \{}
\DoxyCodeLine{35   \textcolor{keyword}{public}:}
\DoxyCodeLine{36     \textcolor{keyword}{using} key\_type = Key;}
\DoxyCodeLine{37     \textcolor{keyword}{using} mapped\_type = Value;}
\DoxyCodeLine{38     \textcolor{keyword}{using} value\_type = std::pair<Key, Value>;}
\DoxyCodeLine{39 }
\DoxyCodeLine{40     \textcolor{keyword}{using} content\_t = Array<std::pair<Key, Value>, Allocator>;}
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{comment}{// currently giving access to keys in a mutable form... that's bad.}}
\DoxyCodeLine{43     \textcolor{comment}{// can't have the key be stored as const because of inplace sorting.}}
\DoxyCodeLine{44     \textcolor{comment}{// this means creating a proxy iterator >< to ensure user cannot screw the ordering.}}
\DoxyCodeLine{45     \textcolor{keyword}{using} size\_type = \textcolor{keyword}{typename} content\_t::size\_type;}
\DoxyCodeLine{46     \textcolor{keyword}{using} difference\_type = \textcolor{keyword}{typename} content\_t::difference\_type;}
\DoxyCodeLine{47     \textcolor{keyword}{using} key\_compare = Comp\_less;}
\DoxyCodeLine{48     \textcolor{keyword}{using} allocator\_type = Allocator;}
\DoxyCodeLine{49     \textcolor{keyword}{using} reference = \textcolor{keyword}{typename} content\_t::reference;}
\DoxyCodeLine{50     \textcolor{keyword}{using} const\_reference = \textcolor{keyword}{typename} content\_t::const\_reference;}
\DoxyCodeLine{51     \textcolor{keyword}{using} pointer = \textcolor{keyword}{typename} content\_t::pointer;}
\DoxyCodeLine{52     \textcolor{keyword}{using} const\_pointer = \textcolor{keyword}{typename} content\_t::const\_pointer;}
\DoxyCodeLine{53     \textcolor{keyword}{using} iterator\_tag = \textcolor{keyword}{typename} std::iterator\_traits<typename content\_t::iterator>::iterator\_category;}
\DoxyCodeLine{54     \textcolor{keyword}{using} const\_iterator\_tag = \textcolor{keyword}{typename} std::iterator\_traits<typename content\_t::const\_iterator>::iterator\_category;}
\DoxyCodeLine{55     \textcolor{keyword}{static\_assert}(std::is\_same\_v<iterator\_tag, std::random\_access\_iterator\_tag>,}
\DoxyCodeLine{56                   \textcolor{stringliteral}{"{}The container type must be random access"{}});}
\DoxyCodeLine{57     \textcolor{keyword}{static\_assert}(std::is\_same\_v<const\_iterator\_tag, std::random\_access\_iterator\_tag>,}
\DoxyCodeLine{58                   \textcolor{stringliteral}{"{}The container type must be random access"{}});}
\DoxyCodeLine{59     \textcolor{keyword}{class }\mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}};}
\DoxyCodeLine{60     \textcolor{keyword}{class }\mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}} : \textcolor{keyword}{public} boost::stl\_interfaces::iterator\_interface<iterator, iterator\_tag, value\_type, reference, pointer,}
\DoxyCodeLine{61                                                                       difference\_type>}
\DoxyCodeLine{62     \textcolor{comment}{// algorithm specifically for iterator of this type will not accept iterator of a content\_t}}
\DoxyCodeLine{63     \{}
\DoxyCodeLine{64         \textcolor{keyword}{using} it\_type = \textcolor{keyword}{typename} content\_t::iterator;}
\DoxyCodeLine{65         it\_type it;}
\DoxyCodeLine{66         \textcolor{keyword}{friend} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}};}
\DoxyCodeLine{67 }
\DoxyCodeLine{68       \textcolor{keyword}{public}:}
\DoxyCodeLine{69         \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} content\_t::iterator \&in) : it(in) \{\}}
\DoxyCodeLine{70         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}}() : it() \{\}}
\DoxyCodeLine{71         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}} \&in) : it(in.it) \{\}}
\DoxyCodeLine{72         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}} \&operator+=(std::ptrdiff\_t in)}
\DoxyCodeLine{73         \{}
\DoxyCodeLine{74             it += in;}
\DoxyCodeLine{75             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{76         \}}
\DoxyCodeLine{77         \textcolor{comment}{// constexpr difference\_type operator-\/(iterator in) \{ return it -\/ in.it; \}}}
\DoxyCodeLine{78         \textcolor{keyword}{constexpr} value\_type *base() \{ \textcolor{keywordflow}{return} it.base(); \}}
\DoxyCodeLine{79         \textcolor{comment}{// reference operator*() const \{return *it;\}}}
\DoxyCodeLine{80         \textcolor{comment}{// bool operator==( const iterator\& in) \{return it == in.it;\}}}
\DoxyCodeLine{81         \textcolor{keyword}{operator} it\_type()\{\textcolor{keywordflow}{return} it;\}}
\DoxyCodeLine{82         \textcolor{keyword}{operator} \textcolor{keyword}{typename} content\_t::const\_iterator()\{\textcolor{keywordflow}{return} it;\}}
\DoxyCodeLine{83       \textcolor{keyword}{private}:}
\DoxyCodeLine{84         \textcolor{keyword}{friend} boost::stl\_interfaces::access;}
\DoxyCodeLine{85         \textcolor{keyword}{friend} \mbox{\hyperlink{classquantit_1_1flat__map}{flat\_map}};}
\DoxyCodeLine{86         \textcolor{keyword}{constexpr} it\_type \&base\_reference() \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} it; \}}
\DoxyCodeLine{87         \textcolor{keyword}{constexpr} it\_type base\_reference() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} it; \}}
\DoxyCodeLine{88         \textcolor{keyword}{operator} it\_type()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} base\_reference(); \}}
\DoxyCodeLine{89     \}; \textcolor{comment}{// require random access.}}
\DoxyCodeLine{90     \textcolor{keyword}{class }\mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}}}
\DoxyCodeLine{91         : \textcolor{keyword}{public} boost::stl\_interfaces::iterator\_interface<const\_iterator, const\_iterator\_tag, const value\_type,}
\DoxyCodeLine{92                                                            const\_reference,const\_pointer, difference\_type>}
\DoxyCodeLine{93     \textcolor{comment}{// algorithm specifcally for iterator of this type will no accept iterator of a content\_t}}
\DoxyCodeLine{94     \{}
\DoxyCodeLine{95         \textcolor{keyword}{using} it\_type = \textcolor{keyword}{typename} content\_t::const\_iterator;}
\DoxyCodeLine{96         it\_type it;}
\DoxyCodeLine{97 }
\DoxyCodeLine{98       \textcolor{keyword}{public}:}
\DoxyCodeLine{99         \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} content\_t::iterator \&in) : it(in) \{\}}
\DoxyCodeLine{100         \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} content\_t::const\_iterator \&in) : it(in) \{\}}
\DoxyCodeLine{101         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}}() : it() \{\}}
\DoxyCodeLine{102         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}} \&in) : it(in.it) \{\}}
\DoxyCodeLine{103         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}} \&in) : it(in.it) \{\}}
\DoxyCodeLine{104         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classquantit_1_1flat__map_1_1const__iterator}{const\_iterator}} \&operator+=(std::ptrdiff\_t in)}
\DoxyCodeLine{105         \{}
\DoxyCodeLine{106             it += in;}
\DoxyCodeLine{107             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{108         \}}
\DoxyCodeLine{109         \textcolor{comment}{// constexpr difference\_type operator-\/(const\_iterator in) \{ return it -\/ in.it; \}}}
\DoxyCodeLine{110         \textcolor{keyword}{constexpr} \textcolor{keyword}{const} value\_type *base() \{ \textcolor{keywordflow}{return} it.base(); \}}
\DoxyCodeLine{111         \textcolor{comment}{// const\_reference operator*() const \{return *it;\}}}
\DoxyCodeLine{112         \textcolor{comment}{// bool operator==( const const\_iterator\& in) \{return it == in.it;\}}}
\DoxyCodeLine{113         \textcolor{keyword}{operator} it\_type()\{\textcolor{keywordflow}{return} it;\}}
\DoxyCodeLine{114       \textcolor{keyword}{private}:}
\DoxyCodeLine{115         \textcolor{keyword}{friend} boost::stl\_interfaces::access;}
\DoxyCodeLine{116         \textcolor{keyword}{friend} \mbox{\hyperlink{classquantit_1_1flat__map}{flat\_map}};}
\DoxyCodeLine{117         \textcolor{keyword}{constexpr} it\_type \&base\_reference() \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} it; \}}
\DoxyCodeLine{118         \textcolor{keyword}{constexpr} it\_type base\_reference() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} it; \}}
\DoxyCodeLine{119         \textcolor{keyword}{operator} it\_type()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} base\_reference(); \}}
\DoxyCodeLine{120     \}; \textcolor{comment}{// require random access.}}
\DoxyCodeLine{121     \textcolor{keyword}{using} reverse\_iterator = std::reverse\_iterator<iterator>;}
\DoxyCodeLine{122     \textcolor{keyword}{using} const\_reverse\_iterator = std::reverse\_iterator<const\_iterator>;}
\DoxyCodeLine{123     \textcolor{keyword}{class }\mbox{\hyperlink{classquantit_1_1flat__map_1_1value__compare}{value\_compare}}}
\DoxyCodeLine{124     \{}
\DoxyCodeLine{125         \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classquantit_1_1flat__map}{flat\_map}};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127       \textcolor{keyword}{protected}:}
\DoxyCodeLine{128         key\_compare comp;}
\DoxyCodeLine{129 }
\DoxyCodeLine{130       \textcolor{keyword}{public}:}
\DoxyCodeLine{131         \mbox{\hyperlink{classquantit_1_1flat__map_1_1value__compare}{value\_compare}}(Comp\_less \_c) : comp(std::move(\_c)) \{\}}
\DoxyCodeLine{132         \mbox{\hyperlink{classquantit_1_1flat__map_1_1value__compare}{value\_compare}}() : comp() \{\}}
\DoxyCodeLine{133         \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} value\_type \&a, \textcolor{keyword}{const} value\_type \&b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} comp(a.first, b.first); \}}
\DoxyCodeLine{134         \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} value\_type \&a, \textcolor{keyword}{const} key\_type \&b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} comp(a.first, b); \}}
\DoxyCodeLine{135         \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} key\_type \&a, \textcolor{keyword}{const} value\_type \&b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} comp(a, b.first); \}}
\DoxyCodeLine{136         \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} key\_type \&a, \textcolor{keyword}{const} key\_type \&b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} comp(a, b); \}}
\DoxyCodeLine{137     \};}
\DoxyCodeLine{138     \textcolor{comment}{// constructors}}
\DoxyCodeLine{139     \textcolor{comment}{// flat\_map() : comp(), content()\{\};}}
\DoxyCodeLine{140     \textcolor{keyword}{explicit} \mbox{\hyperlink{classquantit_1_1flat__map}{flat\_map}}(size\_type capacity, \textcolor{keyword}{const} key\_compare \&\_comp = key\_compare(),}
\DoxyCodeLine{141                       \textcolor{keyword}{const} allocator\_type \&\_alloc = allocator\_type())}
\DoxyCodeLine{142         : comp(\_comp), content(capacity, \_alloc)}
\DoxyCodeLine{143     \{}
\DoxyCodeLine{144         content.resize(0);}
\DoxyCodeLine{145     \}}
\DoxyCodeLine{146     \textcolor{keyword}{explicit} \mbox{\hyperlink{classquantit_1_1flat__map}{flat\_map}}(\textcolor{keyword}{const} key\_compare \&\_comp, \textcolor{keyword}{const} allocator\_type \&\_alloc = allocator\_type())}
\DoxyCodeLine{147         : comp(\_comp), content(\_alloc)}
\DoxyCodeLine{148     \{}
\DoxyCodeLine{149     \}}
\DoxyCodeLine{150     flat\_map(\textcolor{keyword}{const} allocator\_type \&\_alloc = allocator\_type()) : comp(), content(\_alloc) \{\}}
\DoxyCodeLine{151     flat\_map(content\_t \&\&in) : comp(), content(std::move(in)) \{ \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(content.begin(), content.end()); \}}
\DoxyCodeLine{152     flat\_map(\textcolor{keyword}{const} content\_t \&in) : comp(), content((in)) \{ \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(content.begin(), content.end()); \}}
\DoxyCodeLine{153     \textcolor{keyword}{template} <\textcolor{keyword}{class} InputIt>}
\DoxyCodeLine{154     flat\_map(InputIt first, InputIt last, \textcolor{keyword}{const} key\_compare \&\_comp = key\_compare(),}
\DoxyCodeLine{155              \textcolor{keyword}{const} allocator\_type \&\_alloc = allocator\_type())}
\DoxyCodeLine{156         : comp(\_comp), content(first, last, \_alloc)}
\DoxyCodeLine{157     \{}
\DoxyCodeLine{158         \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(content.begin(), content.end());}
\DoxyCodeLine{159         \textcolor{keyword}{auto} l = filter\_unique(content.begin(), content.end());}
\DoxyCodeLine{160         content.resize(std::distance(content.begin(), l));}
\DoxyCodeLine{161     \}}
\DoxyCodeLine{162     \textcolor{keyword}{template} <\textcolor{keyword}{class} InputIt>}
\DoxyCodeLine{163     flat\_map(InputIt first, InputIt last, \textcolor{keyword}{const} allocator\_type \&\_alloc) : comp(), content(first, last, \_alloc)}
\DoxyCodeLine{164     \{}
\DoxyCodeLine{165         \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(content.begin(), content.end());}
\DoxyCodeLine{166         \textcolor{keyword}{auto} l = filter\_unique(content.begin(), content.end());}
\DoxyCodeLine{167         content.resize(std::distance(content.begin(), l));}
\DoxyCodeLine{168     \}}
\DoxyCodeLine{169     flat\_map(\textcolor{keyword}{const} flat\_map \&other) : comp(other.comp), content(other.content) \{\}}
\DoxyCodeLine{170     flat\_map(\textcolor{keyword}{const} flat\_map \&other, \textcolor{keyword}{const} allocator\_type \&alloc) : comp(other.comp), content(other.content, alloc) \{\}}
\DoxyCodeLine{171     flat\_map(flat\_map \&\&other) : comp(std::move(other.comp)), content(std::move(other.content)) \{\}}
\DoxyCodeLine{172     flat\_map(flat\_map \&\&other, \textcolor{keyword}{const} allocator\_type \&alloc)}
\DoxyCodeLine{173         : comp(std::move(other.comp)), content(std::move(other.content), alloc)}
\DoxyCodeLine{174     \{}
\DoxyCodeLine{175     \}}
\DoxyCodeLine{176     flat\_map(std::initializer\_list<value\_type> init) : comp(), content(std::move(init))}
\DoxyCodeLine{177     \{}
\DoxyCodeLine{178         \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(content.begin(), content.end());}
\DoxyCodeLine{179         \textcolor{keyword}{auto} l = filter\_unique(content.begin(), content.end());}
\DoxyCodeLine{180         content.resize(std::distance(content.begin(), l));}
\DoxyCodeLine{181     \}}
\DoxyCodeLine{182     flat\_map(std::initializer\_list<value\_type> init, \textcolor{keyword}{const} value\_compare \&\_comp, \textcolor{keyword}{const} allocator\_type \&alloc)}
\DoxyCodeLine{183         : comp(\_comp), content(std::move(init), alloc)}
\DoxyCodeLine{184     \{}
\DoxyCodeLine{185         \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(content.begin(), content.end());}
\DoxyCodeLine{186         \textcolor{keyword}{auto} l = filter\_unique(content.begin(), content.end());}
\DoxyCodeLine{187         content.resize(std::distance(content.begin(), l));}
\DoxyCodeLine{188     \}}
\DoxyCodeLine{189     flat\_map(std::initializer\_list<value\_type> init, \textcolor{keyword}{const} allocator\_type \&alloc)}
\DoxyCodeLine{190         : comp(), content(std::move(init), alloc)}
\DoxyCodeLine{191     \{}
\DoxyCodeLine{192         \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(content.begin(), content.end());}
\DoxyCodeLine{193         \textcolor{keyword}{auto} l = filter\_unique(content.begin(), content.end());}
\DoxyCodeLine{194         content.resize(std::distance(content.begin(), l));}
\DoxyCodeLine{195     \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197     \textcolor{comment}{// assigment}}
\DoxyCodeLine{198     flat\_map \&operator=(\textcolor{keyword}{const} flat\_map \&other)}
\DoxyCodeLine{199     \{}
\DoxyCodeLine{200         content = other.content;}
\DoxyCodeLine{201         comp = other.comp;}
\DoxyCodeLine{202         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{203     \}}
\DoxyCodeLine{204     flat\_map \&operator=(flat\_map \&\&other) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{205     \{}
\DoxyCodeLine{206         content = std::move(other.content);}
\DoxyCodeLine{207         comp = std::move(other.comp);}
\DoxyCodeLine{208         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{209     \}}
\DoxyCodeLine{218     \mbox{\hyperlink{classquantit_1_1flat__map}{flat\_map}} \&\mbox{\hyperlink{classquantit_1_1flat__map_a50a92e814b4cb5c9ec975857e86743de}{operator=}}(std::initializer\_list<value\_type> ilist)}
\DoxyCodeLine{219     \{}
\DoxyCodeLine{220         content.resize(0);}
\DoxyCodeLine{221         content.insert(ilist.begin(), ilist.end());}
\DoxyCodeLine{222         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{223     \}}
\DoxyCodeLine{224 }
\DoxyCodeLine{225     allocator\_type get\_allocator() const noexcept \{ \textcolor{keywordflow}{return} content.get\_allocator(); \}}
\DoxyCodeLine{226     \textcolor{comment}{// element access}}
\DoxyCodeLine{227     mapped\_type \&at(\textcolor{keyword}{const} key\_type \&key)}
\DoxyCodeLine{228     \{}
\DoxyCodeLine{229         \textcolor{keyword}{auto} it = std::lower\_bound(content.begin(), content.end(), key, comp);}
\DoxyCodeLine{230         \textcolor{keywordflow}{if} (it == content.end() or comp(key, *it))}
\DoxyCodeLine{231             \textcolor{comment}{// we should enter here only if *it != key or it is at the end}}
\DoxyCodeLine{232             \textcolor{keywordflow}{throw} std::out\_of\_range(\textcolor{stringliteral}{"{}key absent from flat\_map."{}});}
\DoxyCodeLine{233         \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{234     \}}
\DoxyCodeLine{235     \textcolor{keyword}{const} mapped\_type \&at(\textcolor{keyword}{const} key\_type \&key)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}flat\_map *\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>at(key); \}}
\DoxyCodeLine{236     mapped\_type \&operator[](\textcolor{keyword}{const} key\_type key)}
\DoxyCodeLine{237     \{}
\DoxyCodeLine{238         \textcolor{keyword}{auto} it = std::lower\_bound(content.begin(), content.end(), key, comp);}
\DoxyCodeLine{239         \textcolor{keywordflow}{if} (it == content.end() or comp(key, *it))}
\DoxyCodeLine{240             it = content.insert(it, std::make\_pair(key, mapped\_type()));}
\DoxyCodeLine{241         \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{242         \textcolor{comment}{// no const version of this one, because it inserts an element if the key isn't already present.}}
\DoxyCodeLine{243     \}}
\DoxyCodeLine{244     \textcolor{comment}{// iterators}}
\DoxyCodeLine{245     iterator begin() \{ \textcolor{keywordflow}{return} iterator(content.begin()); \}}
\DoxyCodeLine{246     iterator end() \{ \textcolor{keywordflow}{return} iterator(content.end()); \}}
\DoxyCodeLine{247     const\_iterator cbegin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} const\_iterator(content.cbegin()); \}}
\DoxyCodeLine{248     const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} const\_iterator(cbegin()); \}}
\DoxyCodeLine{249     const\_iterator cend()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} const\_iterator(content.cend()); \}}
\DoxyCodeLine{250     const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} cend(); \}}
\DoxyCodeLine{251     reverse\_iterator rbegin() \{ \textcolor{keywordflow}{return} reverse\_iterator(end()); \}}
\DoxyCodeLine{252     reverse\_iterator rend() \{ \textcolor{keywordflow}{return} reverse\_iterator(begin()); \}}
\DoxyCodeLine{253     const\_reverse\_iterator crbegin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} const\_reverse\_iterator(cend()); \}}
\DoxyCodeLine{254     const\_reverse\_iterator rbegin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} crbegin(); \}}
\DoxyCodeLine{255     const\_reverse\_iterator crend()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} const\_reverse\_iterator(cbegin()); \}}
\DoxyCodeLine{256     const\_reverse\_iterator rend()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} crend(); \}}
\DoxyCodeLine{257     \textcolor{comment}{// capacity}}
\DoxyCodeLine{258     \textcolor{keywordtype}{bool} empty()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} content.empty(); \}}
\DoxyCodeLine{259     size\_type size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} content.size(); \}}
\DoxyCodeLine{260     size\_type capacity()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} content.capacity(); \}}
\DoxyCodeLine{261     size\_type max\_size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} content.max\_size(); \}}
\DoxyCodeLine{262     \textcolor{keywordtype}{void} reserve(size\_type new\_cap) \{ content.reserve(new\_cap); \}}
\DoxyCodeLine{263     \textcolor{keywordtype}{void} resize(size\_type new\_size) \{ content.resize(new\_size); \}}
\DoxyCodeLine{264     \textcolor{keywordtype}{void} shrink\_to\_fit() \{ content.shrink\_to\_fit(); \}}
\DoxyCodeLine{265     \textcolor{comment}{// modifiers}}
\DoxyCodeLine{266     \textcolor{keywordtype}{void} clear() \{ content.clear(); \}}
\DoxyCodeLine{267     std::pair<iterator, bool> insert(\textcolor{keyword}{const} value\_type \&value)}
\DoxyCodeLine{268     \{}
\DoxyCodeLine{269         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false}; \textcolor{comment}{// true if the value was actually inserted.}}
\DoxyCodeLine{270         \textcolor{keyword}{auto} it = std::lower\_bound(begin(), end(), value.first, comp);}
\DoxyCodeLine{271         \textcolor{keywordflow}{if} (it ==end() or it-\/>first != value.first)}
\DoxyCodeLine{272         \{}
\DoxyCodeLine{273             it = iterator(content.insert(it.base\_reference(), value));}
\DoxyCodeLine{274             success = \textcolor{keyword}{true};}
\DoxyCodeLine{275         \}}
\DoxyCodeLine{276         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{277     \}}
\DoxyCodeLine{278     std::pair<iterator, bool> insert(value\_type \&\&value)}
\DoxyCodeLine{279     \{}
\DoxyCodeLine{280         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false}; \textcolor{comment}{// true if the value was actually inserted.}}
\DoxyCodeLine{281         \textcolor{keyword}{auto} it = std::lower\_bound(begin(), end(), value.first, comp);}
\DoxyCodeLine{282         \textcolor{keywordflow}{if} ( it == end() or it-\/>first != value.first)}
\DoxyCodeLine{283         \{}
\DoxyCodeLine{284             it = iterator(content.insert(it.base\_reference(), std::move(value)));}
\DoxyCodeLine{285             success = \textcolor{keyword}{true};}
\DoxyCodeLine{286         \}}
\DoxyCodeLine{287         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{288     \}}
\DoxyCodeLine{289     \textcolor{keyword}{template} <\textcolor{keyword}{class} P, \textcolor{keyword}{class} = std::enable\_if\_t<std::is\_constructible\_v<value\_type, P\&\&>>>}
\DoxyCodeLine{290     std::pair<iterator, bool> insert(P\&\& value)}
\DoxyCodeLine{291     \{}
\DoxyCodeLine{292         \textcolor{keyword}{static\_assert}(std::is\_constructible\_v<value\_type, P \&\&>, \textcolor{stringliteral}{"{}Don't try to bypass the enable if"{}});}
\DoxyCodeLine{293         \textcolor{keywordflow}{return} insert(value\_type(std::forward<P>(value)));}
\DoxyCodeLine{294     \}}
\DoxyCodeLine{295     iterator insert(const\_iterator hint, \textcolor{keyword}{const} value\_type\& value)}
\DoxyCodeLine{296     \{}
\DoxyCodeLine{297         \textcolor{keyword}{auto} [first, last] = use\_hint(hint, value.first);}
\DoxyCodeLine{298         \textcolor{keyword}{auto} it = std::lower\_bound(}
\DoxyCodeLine{299             first, last, value,}
\DoxyCodeLine{300             comp); \textcolor{comment}{// that's not a big saving if the hint is really good. except if the element is near the ends}}
\DoxyCodeLine{301         \textcolor{keywordflow}{if} (it == end() or it-\/>first != value.first)}
\DoxyCodeLine{302         \{}
\DoxyCodeLine{303             \textcolor{keywordflow}{return} iterator(content.insert(it.base\_reference(), value ));}
\DoxyCodeLine{304         \}}
\DoxyCodeLine{305         \textcolor{keywordflow}{return} erase(it,it); \textcolor{comment}{//convert the const\_iterator in an iterator}}
\DoxyCodeLine{306     \}}
\DoxyCodeLine{307     iterator insert(const\_iterator hint, value\_type \&\&value)}
\DoxyCodeLine{308     \{}
\DoxyCodeLine{309         \textcolor{keyword}{auto} [first, last] = use\_hint(hint, value.first);}
\DoxyCodeLine{310         \textcolor{keyword}{auto} it = std::lower\_bound(}
\DoxyCodeLine{311             first, last, value,}
\DoxyCodeLine{312             comp); \textcolor{comment}{// that's not a big saving if the hint is really good. except if the element is near the ends}}
\DoxyCodeLine{313         \textcolor{keywordflow}{if} (it == end() or it-\/>first != value.first)}
\DoxyCodeLine{314         \{}
\DoxyCodeLine{315             \textcolor{keywordflow}{return} iterator(content.insert(it.base\_reference(), std::move(value)));}
\DoxyCodeLine{316         \}}
\DoxyCodeLine{317         \textcolor{keywordflow}{return} erase(it,it);}
\DoxyCodeLine{318     \}}
\DoxyCodeLine{319     \textcolor{keyword}{template} <\textcolor{keyword}{class} P, \textcolor{keyword}{class} = std::enable\_if\_t<std::is\_constructible\_v<value\_type, P\&\&> >>}
\DoxyCodeLine{320     iterator insert(const\_iterator hint, P\&\&  value)}
\DoxyCodeLine{321     \{}
\DoxyCodeLine{322         \textcolor{keyword}{static\_assert}(std::is\_constructible\_v<value\_type, P\&\&>, \textcolor{stringliteral}{"{}Don't try to bypass the enable if"{}});}
\DoxyCodeLine{323         \textcolor{keywordflow}{return} insert(hint, value\_type(std::forward<P>(value)));}
\DoxyCodeLine{324     \}}
\DoxyCodeLine{325     \textcolor{keyword}{template} <\textcolor{keyword}{class} InputIt>}
\DoxyCodeLine{326     \textcolor{keywordtype}{void} insert(InputIt first, InputIt last)}
\DoxyCodeLine{327     \{}
\DoxyCodeLine{328         insert(}
\DoxyCodeLine{329             first, last, [](\textcolor{keyword}{auto} \&, \textcolor{keyword}{const} \textcolor{keyword}{auto} \&) \{\}, [](\textcolor{keyword}{auto} \&) \{\});}
\DoxyCodeLine{330     \}}
\DoxyCodeLine{331     \textcolor{keyword}{template} <\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} Collision, \textcolor{keyword}{class} = std::enable\_if\_t<!std::is\_convertible\_v<InputIt, const\_iterator>>>}
\DoxyCodeLine{332     \textcolor{keywordtype}{void} insert(InputIt first, InputIt last, Collision \&\&collision)}
\DoxyCodeLine{333     \{}
\DoxyCodeLine{334         \textcolor{keyword}{static\_assert}(!std::is\_convertible\_v<InputIt, const\_iterator>, \textcolor{stringliteral}{"{}Don't try to bypass the enable if"{}});}
\DoxyCodeLine{335         content.insert(content.end(), const\_iterator(first).base\_reference(),const\_iterator(last).base\_reference());}
\DoxyCodeLine{336         \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}();}
\DoxyCodeLine{337         \textcolor{keyword}{auto} l = filter\_unique(}
\DoxyCodeLine{338             content.begin(), content.end(),}
\DoxyCodeLine{339             std::forward<Collision>(collision)); \textcolor{comment}{// pack the unique element at the begining, mainting order}}
\DoxyCodeLine{340         content.resize(l -\/ content.begin());             \textcolor{comment}{// l is the new end pointer.}}
\DoxyCodeLine{341     \}}
\DoxyCodeLine{342     \textcolor{keyword}{template} <\textcolor{keyword}{class} Collision>}
\DoxyCodeLine{343     \textcolor{keywordtype}{void} insert(const\_iterator first, const\_iterator last, Collision \&\&collision)}
\DoxyCodeLine{344     \{}
\DoxyCodeLine{345         insert(first, last, std::forward<Collision>(collision), [](\textcolor{keyword}{auto} \&\&x) \{\});}
\DoxyCodeLine{346     \}}
\DoxyCodeLine{347     \textcolor{comment}{// specialisation for the case of a inserting an ordered array, we can take some small shortcut in that case.}}
\DoxyCodeLine{348     \textcolor{comment}{// should be templated on the iterator such that it accept iterator to ordered array with a value\_type convertible}}
\DoxyCodeLine{349     \textcolor{comment}{// to this value\_type.}}
\DoxyCodeLine{350     \textcolor{keyword}{template} <\textcolor{keyword}{class} Collision, \textcolor{keyword}{class} NoCollision>}
\DoxyCodeLine{351     \textcolor{keywordtype}{void} insert(const\_iterator first, const\_iterator last, Collision \&\&collision, NoCollision \&\&nocollision)}
\DoxyCodeLine{352     \{}
\DoxyCodeLine{353         \textcolor{keyword}{auto} look = begin();}
\DoxyCodeLine{354         \{}
\DoxyCodeLine{355             \textcolor{keyword}{auto} n1 = std::distance(first, last); \textcolor{comment}{// n1 is the number of element to be copied.}}
\DoxyCodeLine{356             \textcolor{comment}{// in first approxiamtion, it's the number of element in the input}}
\DoxyCodeLine{357             \textcolor{comment}{// detect collisions between content and the input iterators.}}
\DoxyCodeLine{358             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = first; i != last; ++i)}
\DoxyCodeLine{359             \{}
\DoxyCodeLine{360                 look = std::lower\_bound(look, end(), *i, comp);}
\DoxyCodeLine{361                 \textcolor{keywordflow}{if} (look == end())}
\DoxyCodeLine{362                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{363                 \textcolor{keywordflow}{if} (!comp(*i, *look))}
\DoxyCodeLine{364                 \{}
\DoxyCodeLine{365                     -\/-\/n1; \textcolor{comment}{// correct it by counting all the collisions.}}
\DoxyCodeLine{366                 \}}
\DoxyCodeLine{367             \}}
\DoxyCodeLine{368             content.resize(content.size() +}
\DoxyCodeLine{369                            n1); \textcolor{comment}{// potentially invalidates iterators. could be more time efficient if we need to}}
\DoxyCodeLine{370                                 \textcolor{comment}{// reallocate, at the cost of holding the previous memory space  abit longer}}
\DoxyCodeLine{371             \textcolor{comment}{// Copy the stuff from the input that has a larger key than the largest key in this.}}
\DoxyCodeLine{372             look = end() -\/ n1;    \textcolor{comment}{// the pointer past the end of the original, to be moved, elements}}
\DoxyCodeLine{373         \}                         \textcolor{comment}{// pop n1 from the stack}}
\DoxyCodeLine{374         \textcolor{keyword}{auto} move\_to\_end = end(); \textcolor{comment}{// for copy backward}}
\DoxyCodeLine{375         \textcolor{comment}{// potential optimization: if move\_to\_end==look at this point, all new elements are colliding.}}
\DoxyCodeLine{376         \textcolor{keywordflow}{while} (look != begin() and last != first)}
\DoxyCodeLine{377         \{}
\DoxyCodeLine{378             \textcolor{keyword}{decltype}(first -\/ last) found\_collision;}
\DoxyCodeLine{379             \textcolor{comment}{// part A: copy element in [first,last[ larger than *(look-\/1) at move\_to\_end.}}
\DoxyCodeLine{380             \{}
\DoxyCodeLine{381                 \textcolor{keyword}{auto} la = std::lower\_bound(first, last, *(look -\/ 1), comp);}
\DoxyCodeLine{382                 found\_collision = la != last and !comp(*(look -\/ 1), *la); \textcolor{comment}{// checked wether the lowest on the range to copy is colliding}}
\DoxyCodeLine{383                 std::copy\_backward(la + found\_collision, last, move\_to\_end); \textcolor{comment}{//we don't copy the colliding element}}
\DoxyCodeLine{384                 \textcolor{keyword}{auto} old\_move\_to\_end = move\_to\_end;}
\DoxyCodeLine{385                 \textcolor{keyword}{auto} move\_shift = last -\/ (la + found\_collision);}
\DoxyCodeLine{386                 move\_to\_end -\/= move\_shift ;}
\DoxyCodeLine{387                 std::for\_each(move\_to\_end, old\_move\_to\_end, [nocollision](\textcolor{keyword}{auto} \&\&x) \{ nocollision(std::get<1>(x)); \});}
\DoxyCodeLine{388                 \textcolor{keywordflow}{if} (found\_collision)}
\DoxyCodeLine{389                 \{}
\DoxyCodeLine{390                     -\/-\/move\_to\_end;}
\DoxyCodeLine{391                     -\/-\/look;}
\DoxyCodeLine{392                     \textcolor{keywordflow}{if}(move\_to\_end != look) *move\_to\_end = std::move( *(look));}
\DoxyCodeLine{393                     collision(move\_to\_end-\/>second,la-\/>second);\textcolor{comment}{//can be called on a parallel thread, the tensor will not be touched again.}}
\DoxyCodeLine{394                 \}}
\DoxyCodeLine{395                 last = la;}
\DoxyCodeLine{396             \} \textcolor{comment}{// pop la from the stack}}
\DoxyCodeLine{397             \textcolor{comment}{// part B: move the elements in [begin,look[ that are greater than *(last-\/1) to move\_to\_end}}
\DoxyCodeLine{398             \textcolor{keywordflow}{if} (last == first)}
\DoxyCodeLine{399                 \textcolor{keywordflow}{break}; \textcolor{comment}{// we've copied everything, there's nothing to move. //ignore collision on the first elements...}}
\DoxyCodeLine{400             \{}
\DoxyCodeLine{401                 \textcolor{keyword}{auto} lb = std::lower\_bound(begin(), look, *(last -\/ 1), comp);}
\DoxyCodeLine{402                 \textcolor{keywordflow}{if} (move\_to\_end != look)}
\DoxyCodeLine{403                     std::move\_backward(lb, look,}
\DoxyCodeLine{404                                        move\_to\_end); \textcolor{comment}{// we don't have to do anything here if move\_to\_end == look. plus}}
\DoxyCodeLine{405                                                      \textcolor{comment}{// move\_backward behavior is undefined in that case (depends on the implementation of the element's move).}}
\DoxyCodeLine{406                 \textcolor{comment}{// if (found\_collision)}}
\DoxyCodeLine{407                 \textcolor{comment}{//  collision((move\_to\_end -\/ 1)-\/>second,}}
\DoxyCodeLine{408                 \textcolor{comment}{//            last-\/>second); // if we move the collision treatment here, we allow parallelism.}}
\DoxyCodeLine{409                 move\_to\_end -\/= look -\/ lb;}
\DoxyCodeLine{410                 look = lb;}
\DoxyCodeLine{411             \} \textcolor{comment}{// pop lb from the stack}}
\DoxyCodeLine{412             found\_collision = last != first and !comp(*(last -\/ 1), *move\_to\_end);}
\DoxyCodeLine{413             \textcolor{keywordflow}{if} (found\_collision)}
\DoxyCodeLine{414                 collision(move\_to\_end-\/>second,}
\DoxyCodeLine{415                           (last -\/ 1)-\/>second); \textcolor{comment}{// if we move collision treatment here, to allow parallelism}}
\DoxyCodeLine{416             last -\/= found\_collision;}
\DoxyCodeLine{417         \}}
\DoxyCodeLine{418         \textcolor{keyword}{auto} lastmfirst = last-\/first;}
\DoxyCodeLine{419         \textcolor{keyword}{auto} movembegin = move\_to\_end -\/ begin();}
\DoxyCodeLine{420         assert(}
\DoxyCodeLine{421             lastmfirst == 0 or}
\DoxyCodeLine{422             movembegin == lastmfirst); \textcolor{comment}{// we've copied everything, or we still have some stuff to copy and the room necessary}}
\DoxyCodeLine{423         std::copy\_backward(first, last, move\_to\_end);}
\DoxyCodeLine{424         std::for\_each(begin(), move\_to\_end, [nocollision](\textcolor{keyword}{auto} \&\&x) \{ nocollision(std::get<1>(x)); \});}
\DoxyCodeLine{425     \}}
\DoxyCodeLine{426 }
\DoxyCodeLine{427     \textcolor{keyword}{template} <\textcolor{keyword}{class} M>}
\DoxyCodeLine{428     std::pair<iterator, bool> insert\_or\_assign(\textcolor{keyword}{const} key\_type \&k, M \&\&obj)}
\DoxyCodeLine{429     \{}
\DoxyCodeLine{430         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false}; \textcolor{comment}{// true if the value was actually inserted.}}
\DoxyCodeLine{431         \textcolor{keyword}{auto} it = std::lower\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{432         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{433         \{}
\DoxyCodeLine{434             it = content.emplace(it, k, std::forward<M>(obj));}
\DoxyCodeLine{435             success = \textcolor{keyword}{true};}
\DoxyCodeLine{436         \}}
\DoxyCodeLine{437         \textcolor{keywordflow}{else}}
\DoxyCodeLine{438         \{}
\DoxyCodeLine{439             *it = value\_type(k, std::forward<M>(obj));}
\DoxyCodeLine{440         \}}
\DoxyCodeLine{441         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{442     \}}
\DoxyCodeLine{443     \textcolor{keyword}{template} <\textcolor{keyword}{class} M>}
\DoxyCodeLine{444     std::pair<iterator, bool> insert\_or\_assign(key\_type \&\&k, M \&\&obj)}
\DoxyCodeLine{445     \{}
\DoxyCodeLine{446         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false}; \textcolor{comment}{// true if the value was actually inserted.}}
\DoxyCodeLine{447         \textcolor{keyword}{auto} it = std::lower\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{448         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{449         \{}
\DoxyCodeLine{450             it = content.emplace(it, std::move(k), std::forward<M>(obj));}
\DoxyCodeLine{451             success = \textcolor{keyword}{true};}
\DoxyCodeLine{452         \}}
\DoxyCodeLine{453         \textcolor{keywordflow}{else}}
\DoxyCodeLine{454         \{}
\DoxyCodeLine{455             *it = value\_type(std::move(k), std::forward<M>(obj));}
\DoxyCodeLine{456         \}}
\DoxyCodeLine{457         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{458     \}}
\DoxyCodeLine{459     \textcolor{keyword}{template} <\textcolor{keyword}{class} M>}
\DoxyCodeLine{460     iterator insert\_or\_assign(const\_iterator hint, \textcolor{keyword}{const} key\_type \&k, M \&\&obj)}
\DoxyCodeLine{461     \{}
\DoxyCodeLine{462 }
\DoxyCodeLine{463         \textcolor{keyword}{auto} [first, last] = use\_hint(hint, k);}
\DoxyCodeLine{464         iterator it = std::lower\_bound(}
\DoxyCodeLine{465             first, last, k,}
\DoxyCodeLine{466             comp); \textcolor{comment}{// that's not a big saving if the hint is really good. except if the element is near the ends}}
\DoxyCodeLine{467         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{468         \{}
\DoxyCodeLine{469             it = content.emplace(it, k, std::forward<M>(obj));}
\DoxyCodeLine{470         \}}
\DoxyCodeLine{471         \textcolor{keywordflow}{else}}
\DoxyCodeLine{472         \{}
\DoxyCodeLine{473             *it = value\_type(k, std::forward<M>(obj));}
\DoxyCodeLine{474         \}}
\DoxyCodeLine{475 }
\DoxyCodeLine{476         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{477     \}}
\DoxyCodeLine{478     \textcolor{keyword}{template} <\textcolor{keyword}{class} M>}
\DoxyCodeLine{479     iterator insert\_or\_assign(const\_iterator hint, key\_type \&\&k, M \&\&obj)}
\DoxyCodeLine{480     \{}
\DoxyCodeLine{481         \textcolor{keyword}{auto} [first, last] = use\_hint(hint, k);}
\DoxyCodeLine{482         iterator it = std::lower\_bound(}
\DoxyCodeLine{483             first, last, k,}
\DoxyCodeLine{484             comp); \textcolor{comment}{// that's not a big saving if the hint is really good. except if the element is near the ends}}
\DoxyCodeLine{485         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{486         \{}
\DoxyCodeLine{487             it = content.emplace(it, std::move(k), std::forward<M>(obj));}
\DoxyCodeLine{488         \}}
\DoxyCodeLine{489         \textcolor{keywordflow}{else}}
\DoxyCodeLine{490         \{}
\DoxyCodeLine{491             *it = value\_type(std::move(k), std::forward<M>(obj));}
\DoxyCodeLine{492         \}}
\DoxyCodeLine{493         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{494     \}}
\DoxyCodeLine{495     \textcolor{keyword}{template} <\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{496     std::pair<iterator, bool> emplace(Args \&\&... args)}
\DoxyCodeLine{497     \{}
\DoxyCodeLine{498         value\_type val(std::forward<Args>(args)...);}
\DoxyCodeLine{499         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{500         \textcolor{keyword}{auto} it = std::lower\_bound(begin(), end(), val, comp);}
\DoxyCodeLine{501         \textcolor{keywordflow}{if} (it  == end() or comp(val, *it))}
\DoxyCodeLine{502         \{}
\DoxyCodeLine{503             it = content.emplace(it.it, std::move(val));}
\DoxyCodeLine{504             success = \textcolor{keyword}{true};}
\DoxyCodeLine{505         \}}
\DoxyCodeLine{506         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{507     \}}
\DoxyCodeLine{508     \textcolor{keyword}{template} <\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{509     std::pair<iterator, bool> emplace(const\_iterator hint, Args \&\&... args)}
\DoxyCodeLine{510     \{}
\DoxyCodeLine{511         value\_type val(std::forward<Args>(args)...);}
\DoxyCodeLine{512         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{513         \textcolor{keyword}{auto} [first, last] = use\_hint(hint, val.first);}
\DoxyCodeLine{514         iterator it;}
\DoxyCodeLine{515         hint = std::lower\_bound(}
\DoxyCodeLine{516             first, last, val,}
\DoxyCodeLine{517             comp); \textcolor{comment}{// that's not a big saving if the hint is really good. except if the element is near the ends. So far, at the end is the typical case.}}
\DoxyCodeLine{518         \textcolor{keywordflow}{if} (hint == cend() or comp(val, *hint))}
\DoxyCodeLine{519         \{}
\DoxyCodeLine{520             it.it = content.emplace(hint.it, std::move(val));}
\DoxyCodeLine{521             success = \textcolor{keyword}{true};}
\DoxyCodeLine{522         \}}
\DoxyCodeLine{523         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{524     \}}
\DoxyCodeLine{525     \textcolor{keyword}{template} <\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{526     std::pair<iterator, bool> emplace(iterator hint, Args \&\&... args)}
\DoxyCodeLine{527     \{}
\DoxyCodeLine{528         \textcolor{keywordflow}{return} emplace(const\_iterator(hint), std::forward<Args>(args)...);}
\DoxyCodeLine{529     \}}
\DoxyCodeLine{530 }
\DoxyCodeLine{531     \textcolor{keyword}{template} <\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{532     std::pair<iterator, bool> try\_emplace(\textcolor{keyword}{const} key\_type \&k, Args \&\&... args)}
\DoxyCodeLine{533     \{}
\DoxyCodeLine{534         iterator it = std::lower\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{535         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{536         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{537         \{}
\DoxyCodeLine{538             it = content.emplace(it, k, std::forward<Args>(args)...);}
\DoxyCodeLine{539             success = \textcolor{keyword}{true};}
\DoxyCodeLine{540         \}}
\DoxyCodeLine{541         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{542     \}}
\DoxyCodeLine{543     \textcolor{keyword}{template} <\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{544     std::pair<iterator, bool> try\_emplace(key\_type \&\&k, Args \&\&... args)}
\DoxyCodeLine{545     \{}
\DoxyCodeLine{546         iterator it = std::lower\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{547         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{548         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{549         \{}
\DoxyCodeLine{550             it = content.emplace(it, std::move(k), std::forward<Args>(args)...);}
\DoxyCodeLine{551             success = \textcolor{keyword}{true};}
\DoxyCodeLine{552         \}}
\DoxyCodeLine{553         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{554     \}}
\DoxyCodeLine{555     \textcolor{keyword}{template} <\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{556     std::pair<iterator, bool> try\_emplace(const\_iterator hint, \textcolor{keyword}{const} key\_type \&k, Args \&\&... args)}
\DoxyCodeLine{557     \{}
\DoxyCodeLine{558         \textcolor{keyword}{auto} [first, last] = use\_hint(hint, k);}
\DoxyCodeLine{559         iterator it = std::lower\_bound(first, last, k, comp);}
\DoxyCodeLine{560         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{561         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{562         \{}
\DoxyCodeLine{563             it = content.emplace(it, k, std::forward<Args>(args)...);}
\DoxyCodeLine{564             success = \textcolor{keyword}{true};}
\DoxyCodeLine{565         \}}
\DoxyCodeLine{566         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{567     \}}
\DoxyCodeLine{568     \textcolor{keyword}{template} <\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{569     std::pair<iterator, bool> try\_emplace(const\_iterator hint, key\_type \&\&k, Args \&\&... args)}
\DoxyCodeLine{570     \{}
\DoxyCodeLine{571         \textcolor{keyword}{auto} [first, last] = use\_hint(hint, k);}
\DoxyCodeLine{572         iterator it = std::lower\_bound(first, last, k, comp);}
\DoxyCodeLine{573         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{574         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{575         \{}
\DoxyCodeLine{576             it = content.emplace(it, std::move(k), std::forward<Args>(args)...);}
\DoxyCodeLine{577             success = \textcolor{keyword}{true};}
\DoxyCodeLine{578         \}}
\DoxyCodeLine{579         \textcolor{keywordflow}{return} std::make\_pair(it, success);}
\DoxyCodeLine{580     \}}
\DoxyCodeLine{581 }
\DoxyCodeLine{582     iterator erase(const\_iterator pos) \{ \textcolor{keywordflow}{return} iterator(content.erase(pos.base\_reference())); \}}
\DoxyCodeLine{583     iterator erase(iterator pos) \{ \textcolor{keywordflow}{return} iterator(content.erase(pos.base\_reference())); \}}
\DoxyCodeLine{584     iterator erase(const\_iterator first, const\_iterator last) \{ \textcolor{keywordflow}{return} iterator(content.erase(first.base\_reference(), last.base\_reference())); \}}
\DoxyCodeLine{585     size\_type erase(\textcolor{keyword}{const} key\_type \&k)}
\DoxyCodeLine{586     \{}
\DoxyCodeLine{587         \textcolor{keyword}{auto} it = std::lower\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{588         \textcolor{keywordflow}{if} (comp(*it, k))}
\DoxyCodeLine{589         \{}
\DoxyCodeLine{590             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{591         \}}
\DoxyCodeLine{592         content.erase(it);}
\DoxyCodeLine{593         \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{594     \}}
\DoxyCodeLine{595     \textcolor{keywordtype}{void} swap(flat\_map \&other) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{596     \{}
\DoxyCodeLine{597         \textcolor{keyword}{using} std::swap;}
\DoxyCodeLine{598         swap(content, other.content);}
\DoxyCodeLine{599         swap(comp, other.comp);}
\DoxyCodeLine{600     \}}
\DoxyCodeLine{601     \textcolor{keyword}{template} <\textcolor{keyword}{class} C2, \textcolor{keyword}{class} Collision>}
\DoxyCodeLine{602     \textcolor{keywordtype}{void} merge(\textcolor{keyword}{const} flat\_map<key\_type, mapped\_type, C2, allocator\_type> \&source, Collision \&\&collision)}
\DoxyCodeLine{603     \{}
\DoxyCodeLine{604         merge(source, std::forward<Collision>(collision), [](\textcolor{keyword}{auto} \&\&) \{\});}
\DoxyCodeLine{605     \}}
\DoxyCodeLine{606     \textcolor{keyword}{template} <\textcolor{keyword}{class} C2, \textcolor{keyword}{class} Collision, \textcolor{keyword}{class} NoCollision>}
\DoxyCodeLine{607     \textcolor{keywordtype}{void} merge(\textcolor{keyword}{const} flat\_map<key\_type, mapped\_type, C2, allocator\_type> \&source, Collision \&\&collision,}
\DoxyCodeLine{608                NoCollision \&\&nocollision)}
\DoxyCodeLine{609     \{}
\DoxyCodeLine{610         insert(source.begin(), source.end(), std::forward<Collision>(collision),}
\DoxyCodeLine{611                std::forward<NoCollision>(nocollision));}
\DoxyCodeLine{612     \}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614     \textcolor{keyword}{template} <\textcolor{keyword}{class} C2, \textcolor{keyword}{class} Collision>}
\DoxyCodeLine{615     \textcolor{keywordtype}{void} merge(flat\_map<key\_type, mapped\_type, C2, allocator\_type> \&\&source, Collision \&\&collision)}
\DoxyCodeLine{616     \{}
\DoxyCodeLine{617         merge(std::move(source), std::forward<Collision>(collision), [](\textcolor{keyword}{auto} \&\&) \{\});}
\DoxyCodeLine{618     \}}
\DoxyCodeLine{619     \textcolor{keyword}{template} <\textcolor{keyword}{class} C2, \textcolor{keyword}{class} Collision, \textcolor{keyword}{class} NoCollision>}
\DoxyCodeLine{620     \textcolor{keywordtype}{void} merge(flat\_map<key\_type, mapped\_type, C2, allocator\_type> \&\&source, Collision \&\&collision,}
\DoxyCodeLine{621                NoCollision \&\&nocollision)}
\DoxyCodeLine{622     \{}
\DoxyCodeLine{623         \textcolor{keywordflow}{if} (source.capacity() >= source.size() + size()) \textcolor{comment}{// reuse source's resources if it avoid doing an allocation.}}
\DoxyCodeLine{624         \{}
\DoxyCodeLine{625             std::swap(content, source.content); \textcolor{comment}{// if the source has enough capacity, we'll keep it instead.}}
\DoxyCodeLine{626             insert(}
\DoxyCodeLine{627                 source.begin(), source.end(),}
\DoxyCodeLine{628                 [collision](\textcolor{keyword}{auto} \&a, \textcolor{keyword}{auto} \&b) \{}
\DoxyCodeLine{629                     \textcolor{comment}{// b is const in the context that call this lambda function.}}
\DoxyCodeLine{630                     \textcolor{comment}{// But in this present context, we know it's actually a reference to a non-\/const value.}}
\DoxyCodeLine{631                     \textcolor{comment}{// Casting away const in order to change a value should almost never be used.}}
\DoxyCodeLine{632                     auto \&c = const\_cast<std::remove\_const\_t<std::remove\_reference\_t<decltype(b)>> \&>(b);}
\DoxyCodeLine{633                     std::swap(a, c);}
\DoxyCodeLine{634                     collision(a, c);}
\DoxyCodeLine{635                 \},}
\DoxyCodeLine{636                 std::forward<NoCollision>(nocollision));}
\DoxyCodeLine{637         \}}
\DoxyCodeLine{638         \textcolor{keywordflow}{else}}
\DoxyCodeLine{639         \{}
\DoxyCodeLine{640             insert(source.begin(), source.end(), std::forward<Collision>(collision),}
\DoxyCodeLine{641                    std::forward<NoCollision>(nocollision));}
\DoxyCodeLine{642         \}}
\DoxyCodeLine{643     \}}
\DoxyCodeLine{644     \textcolor{keyword}{template} <\textcolor{keyword}{class} C2>}
\DoxyCodeLine{645     \textcolor{keywordtype}{void} merge(\textcolor{keyword}{const} flat\_map<key\_type, mapped\_type, C2, allocator\_type> \&source)}
\DoxyCodeLine{646     \{}
\DoxyCodeLine{647         insert(source.begin(), source.end());}
\DoxyCodeLine{648     \}}
\DoxyCodeLine{649 }
\DoxyCodeLine{650     \textcolor{keyword}{template} <\textcolor{keyword}{class} C2>}
\DoxyCodeLine{651     \textcolor{keywordtype}{void} merge(flat\_map<key\_type, mapped\_type, C2, allocator\_type> \&\&source)}
\DoxyCodeLine{652     \{}
\DoxyCodeLine{653         \textcolor{keywordflow}{if} (source.capacity() >= source.size() + size())}
\DoxyCodeLine{654         \{}
\DoxyCodeLine{655             swap(content, source.content); \textcolor{comment}{// if the source has enough capacity, we'll keep it instead.}}
\DoxyCodeLine{656             insert(source.begin(), source.end(), [](\textcolor{keyword}{auto} \&a, \textcolor{keyword}{const} \textcolor{keyword}{auto} \&b) \{}
\DoxyCodeLine{657                 \textcolor{comment}{// b is const in the context that call this lambda function.}}
\DoxyCodeLine{658                 \textcolor{comment}{// But in this present context, we know it's actually a reference to a non-\/const value.}}
\DoxyCodeLine{659                 \textcolor{comment}{// Casting away const in order to change a value should almost never be used.}}
\DoxyCodeLine{660                 auto \&c = const\_cast<std::remove\_const\_t<std::remove\_reference\_t<decltype(b)>> \&>(b);}
\DoxyCodeLine{661                 using std::swap;}
\DoxyCodeLine{662                 swap(a, c);}
\DoxyCodeLine{663             \});}
\DoxyCodeLine{664         \}}
\DoxyCodeLine{665         \textcolor{keywordflow}{else}}
\DoxyCodeLine{666         \{}
\DoxyCodeLine{667             insert(source.begin(), source.end());}
\DoxyCodeLine{668         \}}
\DoxyCodeLine{669     \}}
\DoxyCodeLine{670     \textcolor{comment}{//TODO: figure out what went wrong with previous implementation of find. It used the flat\_map iterator instead of the content iterator.}}
\DoxyCodeLine{671     \textcolor{comment}{// Suggest a bug in either comp or the iterators.}}
\DoxyCodeLine{672     iterator find(\textcolor{keyword}{const} key\_type \&k)}
\DoxyCodeLine{673     \{}
\DoxyCodeLine{674         \textcolor{keyword}{auto} it = std::lower\_bound(content.begin(), content.end(), k, comp);}
\DoxyCodeLine{675         \textcolor{keywordflow}{if} (it == content.end() or comp(k, *it))}
\DoxyCodeLine{676             \textcolor{comment}{// we should enter here only if *it != key or it is at the end}}
\DoxyCodeLine{677             \textcolor{keywordflow}{return} end();}
\DoxyCodeLine{678         \textcolor{keywordflow}{return} iterator(it);}
\DoxyCodeLine{679     \}}
\DoxyCodeLine{680     const\_iterator find(\textcolor{keyword}{const} key\_type \&k)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}flat\_map *\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>find(k); \}}
\DoxyCodeLine{681     size\_type count(\textcolor{keyword}{const} key\_type \&k)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} find(k) != end(); \}}
\DoxyCodeLine{682     \textcolor{keywordtype}{bool} contains(\textcolor{keyword}{const} key\_type \&k)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count(k); \}}
\DoxyCodeLine{683     std::pair<iterator, iterator> equal\_range(\textcolor{keyword}{const} key\_type \&k)}
\DoxyCodeLine{684     \{}
\DoxyCodeLine{685         \textcolor{keyword}{auto} it = find(k);}
\DoxyCodeLine{686         \textcolor{keywordflow}{return} std::make\_pair(it, it == end() ? end() : it + 1);}
\DoxyCodeLine{687     \}}
\DoxyCodeLine{688     std::pair<const\_iterator, const\_iterator> equal\_range(\textcolor{keyword}{const} key\_type \&k)\textcolor{keyword}{ const}}
\DoxyCodeLine{689 \textcolor{keyword}{    }\{}
\DoxyCodeLine{690         \textcolor{keywordflow}{return} std::make\_from\_tuple<std::pair<const\_iterator, const\_iterator>>(}
\DoxyCodeLine{691             \textcolor{keyword}{const\_cast<}flat\_map *\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>equal\_range(k));}
\DoxyCodeLine{692     \}}
\DoxyCodeLine{693     iterator lower\_bound(\textcolor{keyword}{const} key\_type \&k)}
\DoxyCodeLine{694     \{}
\DoxyCodeLine{695         \textcolor{keyword}{auto} it = std::lower\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{696         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{697             it = end();}
\DoxyCodeLine{698         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{699     \}}
\DoxyCodeLine{700     const\_iterator lower\_bound(\textcolor{keyword}{const} key\_type \&k)\textcolor{keyword}{ const}}
\DoxyCodeLine{701 \textcolor{keyword}{    }\{}
\DoxyCodeLine{702         \textcolor{keyword}{auto} it = std::lower\_bound(cbegin(), cend(), k, comp);}
\DoxyCodeLine{703         \textcolor{keywordflow}{if} (comp(k, *it))}
\DoxyCodeLine{704             it = end();}
\DoxyCodeLine{705         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{706     \}}
\DoxyCodeLine{707     iterator upper\_bound(\textcolor{keyword}{const} key\_type \&k)}
\DoxyCodeLine{708     \{}
\DoxyCodeLine{709         \textcolor{keyword}{auto} it = std::upper\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{710         \textcolor{keywordflow}{if} (comp(*it, k))}
\DoxyCodeLine{711             it = end();}
\DoxyCodeLine{712         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{713     \}}
\DoxyCodeLine{714     const\_iterator upper\_bound(\textcolor{keyword}{const} key\_type \&k)\textcolor{keyword}{ const}}
\DoxyCodeLine{715 \textcolor{keyword}{    }\{}
\DoxyCodeLine{716         \textcolor{keyword}{auto} it = std::upper\_bound(begin(), end(), k, comp);}
\DoxyCodeLine{717         \textcolor{keywordflow}{if} (comp(*it, k))}
\DoxyCodeLine{718             it = end();}
\DoxyCodeLine{719         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{720     \}}
\DoxyCodeLine{721 }
\DoxyCodeLine{722     key\_compare key\_comp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} comp.comp; \}}
\DoxyCodeLine{723 }
\DoxyCodeLine{724     value\_compare value\_comp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} comp; \}}
\DoxyCodeLine{725 }
\DoxyCodeLine{738     \textcolor{keywordtype}{void} \mbox{\hyperlink{classquantit_1_1flat__map_ab86eb4f76adb14729dbfe27d84c4b7d8}{sort}}(\mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}} first, \mbox{\hyperlink{classquantit_1_1flat__map_1_1iterator}{iterator}} last) \{ std::sort(first, last, comp); \}}
\DoxyCodeLine{739     \textcolor{keywordtype}{void} sort() \{ std::sort(begin(), end(), comp); \}}
\DoxyCodeLine{740 }
\DoxyCodeLine{741   \textcolor{keyword}{protected}:}
\DoxyCodeLine{742     value\_compare comp;}
\DoxyCodeLine{743 }
\DoxyCodeLine{744   \textcolor{keyword}{private}:}
\DoxyCodeLine{745     content\_t content;}
\DoxyCodeLine{746     \textcolor{keywordtype}{void} sort(\textcolor{keyword}{typename} content\_t::iterator first, \textcolor{keyword}{typename} content\_t::iterator last) \{ std::sort(first, last, comp); \}}
\DoxyCodeLine{747     \textcolor{comment}{// void remove\_collisions(iterator first = begin(), iterator last = end())}}
\DoxyCodeLine{748     \textcolor{comment}{// \{ //assume a sorted array}}
\DoxyCodeLine{749     \textcolor{comment}{//  auto beg = first while (first != last)}}
\DoxyCodeLine{750     \textcolor{comment}{//  \{}}
\DoxyCodeLine{751     \textcolor{comment}{//  \}}}
\DoxyCodeLine{752     \textcolor{comment}{// \}}}
\DoxyCodeLine{753     std::pair<const\_iterator, const\_iterator> use\_hint(const\_iterator hint,\textcolor{keyword}{const} key\_type \&key)\textcolor{keyword}{ const}}
\DoxyCodeLine{754 \textcolor{keyword}{    }\{}
\DoxyCodeLine{755         }
\DoxyCodeLine{756         \textcolor{keywordflow}{if} (size() == 0) \textcolor{keywordflow}{return} std::make\_pair(cbegin(),cend()); \textcolor{comment}{//empty case.}}
\DoxyCodeLine{757         \textcolor{keywordtype}{bool} is\_end = hint == cend();}
\DoxyCodeLine{758         hint = hint -\/ 1*is\_end;\textcolor{comment}{// avoid dereferencing the end iterator, which isn't a valid value. It an acceptable hint.}}
\DoxyCodeLine{759         const\_iterator first = comp(*hint, key) ? hint : cbegin();}
\DoxyCodeLine{760         const\_iterator last = comp(key, *hint) ? cend() : hint + 1;}
\DoxyCodeLine{761         \textcolor{keywordflow}{return} std::make\_pair(first, last);}
\DoxyCodeLine{762     \}}
\DoxyCodeLine{763     std::pair<iterator, iterator> use\_hint(iterator hint,\textcolor{keyword}{const} key\_type \&key)}
\DoxyCodeLine{764     \{}
\DoxyCodeLine{765         \textcolor{keywordflow}{if} (size() == 0) \textcolor{keywordflow}{return} std::make\_pair(begin(),end()); \textcolor{comment}{//empty case.}}
\DoxyCodeLine{766         \textcolor{keywordtype}{bool} is\_end = hint == end();}
\DoxyCodeLine{767         hint = hint -\/ is\_end;\textcolor{comment}{// avoid dereferencing the end iterator, which isn't a valid value. It an acceptable hint.}}
\DoxyCodeLine{768         iterator first = comp(*hint, key) ? hint : begin();}
\DoxyCodeLine{769         iterator last = comp(key, *hint) ? hint + 1 : end();}
\DoxyCodeLine{770         \textcolor{keywordflow}{return} std::make\_pair(first, last);}
\DoxyCodeLine{771     \}}
\DoxyCodeLine{772     \textcolor{keyword}{typename} content\_t::iterator filter\_unique(\textcolor{keyword}{typename} content\_t::iterator first, \textcolor{keyword}{typename} content\_t::iterator last)}
\DoxyCodeLine{773     \{}
\DoxyCodeLine{774         \textcolor{keywordflow}{return} filter\_unique(first, last, [](\textcolor{keyword}{auto} \&, \textcolor{keyword}{auto} \&) \{\});}
\DoxyCodeLine{775     \}}
\DoxyCodeLine{776     \textcolor{keyword}{template} <\textcolor{keyword}{class} Collision>}
\DoxyCodeLine{777     \textcolor{keyword}{typename} content\_t::iterator filter\_unique(\textcolor{keyword}{typename} content\_t::iterator first, \textcolor{keyword}{typename} content\_t::iterator last,}
\DoxyCodeLine{778                                                Collision \&\&collision)}
\DoxyCodeLine{779     \{ \textcolor{comment}{// no collision get applied to all elements, instead of just the new element inserted.}}
\DoxyCodeLine{780         \textcolor{keyword}{using} std::swap;}
\DoxyCodeLine{781         \textcolor{keyword}{auto} l = first;}
\DoxyCodeLine{782         \textcolor{keyword}{auto} second = std::upper\_bound(first, last, *l, comp);}
\DoxyCodeLine{783         \textcolor{keywordflow}{while} (first != last)}
\DoxyCodeLine{784         \{}
\DoxyCodeLine{785             std::for\_each(first + 1, second, [collision, l](\textcolor{keyword}{auto} \&x) \{ collision(*l, x); \});}
\DoxyCodeLine{786             ++l;}
\DoxyCodeLine{787             \textcolor{keywordflow}{if} (second == last)}
\DoxyCodeLine{788                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{789             swap(*l, *second); \textcolor{comment}{// when there's only one element (i.e. no collision) of a given value it swaps with self.}}
\DoxyCodeLine{790             first = second;}
\DoxyCodeLine{791             second = std::upper\_bound(first, last, *l, comp);}
\DoxyCodeLine{792         \}}
\DoxyCodeLine{793         \textcolor{keywordflow}{return} l;}
\DoxyCodeLine{794     \}}
\DoxyCodeLine{795 \};}
\DoxyCodeLine{796 }
\DoxyCodeLine{797 \textcolor{keyword}{template} <\textcolor{keyword}{class }key, \textcolor{keyword}{class }val, \textcolor{keyword}{class }C1, \textcolor{keyword}{class }C2, \textcolor{keyword}{class }alloc1, \textcolor{keyword}{class }alloc2, \textcolor{keyword}{template} <\textcolor{keyword}{class}...> \textcolor{keyword}{class }array1,}
\DoxyCodeLine{798           \textcolor{keyword}{template} <\textcolor{keyword}{class}...> \textcolor{keyword}{class }array2>}
\DoxyCodeLine{799 \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} flat\_map<key, val, C1, alloc1, array1> \&a, \textcolor{keyword}{const} flat\_map<key, val, C2, alloc2, array2> \&b)}
\DoxyCodeLine{800 \{}
\DoxyCodeLine{801     \textcolor{keywordflow}{if} (\&a == \&b)}
\DoxyCodeLine{802         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{803     \textcolor{keywordflow}{if} (a.size() != b.size())}
\DoxyCodeLine{804         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{805     \textcolor{keyword}{auto} it\_a = a.begin();}
\DoxyCodeLine{806     \textcolor{keyword}{auto} it\_b = b.begin();}
\DoxyCodeLine{807     \textcolor{keywordtype}{bool} out = \textcolor{keyword}{true};}
\DoxyCodeLine{808     \textcolor{keywordflow}{while} (out and it\_a != a.end())}
\DoxyCodeLine{809     \{}
\DoxyCodeLine{810         out \&= *it\_a == *it\_b;}
\DoxyCodeLine{811         ++it\_a;}
\DoxyCodeLine{812         ++it\_b;}
\DoxyCodeLine{813     \}}
\DoxyCodeLine{814     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{815 \}}
\DoxyCodeLine{816 }
\DoxyCodeLine{817 qtt\_TEST\_CASE(\textcolor{stringliteral}{"{}flat\_map"{}})}
\DoxyCodeLine{818 \{}
\DoxyCodeLine{819     flat\_map<int, double> a\{\{40, 1.1\}, \{20, 1.2\}, \{30, 1.3\}, \{10, 1.4\}\};}
\DoxyCodeLine{820     \{}
\DoxyCodeLine{821         \textcolor{keyword}{auto} pre\_ordered = flat\_map<int, double>(}
\DoxyCodeLine{822             \{\{10, 1.4\},}
\DoxyCodeLine{823              \{20, 1.2\},}
\DoxyCodeLine{824              \{30, 1.3\},}
\DoxyCodeLine{825              \{40, 1.1\}\}); \textcolor{comment}{// allocation of the pre-\/ordered flatmap trigger a report from valgrind (invalid read)}}
\DoxyCodeLine{826         qtt\_REQUIRE(a == pre\_ordered);}
\DoxyCodeLine{827     \}}
\DoxyCodeLine{828 }
\DoxyCodeLine{829     \textcolor{comment}{// qtt\_CHECK(false == true);}}
\DoxyCodeLine{830     qtt\_SUBCASE(\textcolor{stringliteral}{"{}insert a flat\_map before, in and at the end, with collisions"{}})}
\DoxyCodeLine{831     \{}
\DoxyCodeLine{832         \textcolor{keywordtype}{int} collisions = 0;}
\DoxyCodeLine{833         flat\_map<int, double> b\{\{1, 6e10\}, \{10, 6e10\}, \{50, 1e10\}, \{30, 1\}, \{33, 1e12\}, \{70, 1e11\}\};}
\DoxyCodeLine{834         flat\_map<int, double> result\{\{1, 6e10\},  \{10, 1.4\}, \{20, 1.2\},  \{30, 1.3\},}
\DoxyCodeLine{835                                      \{33, 1e12\}, \{40, 1.1\}, \{50, 1e10\}, \{70, 1e11\}\};}
\DoxyCodeLine{836         a.insert(b.begin(), b.end(), [\&collisions](\textcolor{keyword}{auto} \&\&, \textcolor{keyword}{auto} \&\&) \{ ++collisions; \});}
\DoxyCodeLine{837         qtt\_CHECK(a == result);}
\DoxyCodeLine{838         qtt\_CHECK(collisions == 2);}
\DoxyCodeLine{839     \}}
\DoxyCodeLine{840     qtt\_SUBCASE(\textcolor{stringliteral}{"{}insert a flat\_map in middle and at the end, with collisions"{}})}
\DoxyCodeLine{841     \{}
\DoxyCodeLine{842         \textcolor{keywordtype}{int} collisions = 0;}
\DoxyCodeLine{843         flat\_map<int, double> b\{\{10, 6e10\}, \{50, 1e10\}, \{33, 1e12\}, \{40, 5.5\}, \{70, 1e11\}\};}
\DoxyCodeLine{844         flat\_map<int, double> result\{\{10, 1.4\}, \{20, 1.2\}, \{30, 1.3\}, \{33, 1e12\}, \{40, 1.1\}, \{50, 1e10\}, \{70, 1e11\}\};}
\DoxyCodeLine{845         a.insert(b.begin(), b.end(), [\&collisions](\textcolor{keyword}{auto} \&\&, \textcolor{keyword}{auto} \&\&) \{ ++collisions; \});}
\DoxyCodeLine{846         qtt\_CHECK(a == result);}
\DoxyCodeLine{847         qtt\_CHECK(collisions == 2);}
\DoxyCodeLine{848     \}}
\DoxyCodeLine{849     qtt\_SUBCASE(\textcolor{stringliteral}{"{}insert a flat\_map in middle, with collisions"{}})}
\DoxyCodeLine{850     \{}
\DoxyCodeLine{851         \textcolor{keywordtype}{int} collisions = 0;}
\DoxyCodeLine{852         flat\_map<int, double> b\{\{10, 6e10\}, \{33, 1e12\}, \{31, 1e12\}, \{40, 5.5\}\};}
\DoxyCodeLine{853         flat\_map<int, double> result\{\{10, 1.4\}, \{20, 1.2\}, \{31, 1e12\}, \{30, 1.3\}, \{33, 1e12\}, \{40, 1.1\}\};}
\DoxyCodeLine{854         a.insert(b.begin(), b.end(), [\&collisions](\textcolor{keyword}{auto} \&\&, \textcolor{keyword}{auto} \&\&) \{ ++collisions; \});}
\DoxyCodeLine{855         qtt\_CHECK(a == result);}
\DoxyCodeLine{856         qtt\_CHECK(collisions == 2);}
\DoxyCodeLine{857     \}}
\DoxyCodeLine{858     qtt\_SUBCASE(\textcolor{stringliteral}{"{}insert a flat\_map before, in middle and at the end, no collisions"{}})}
\DoxyCodeLine{859     \{}
\DoxyCodeLine{860         \textcolor{keywordtype}{int} collisions = 0;}
\DoxyCodeLine{861         flat\_map<int, double> b\{\{1, 6e10\}, \{50, 1e10\}, \{33, 1e12\}, \{70, 1e11\}\};}
\DoxyCodeLine{862         flat\_map<int, double> result\{\{1, 6e10\},  \{10, 1.4\}, \{20, 1.2\},  \{30, 1.3\},}
\DoxyCodeLine{863                                      \{33, 1e12\}, \{40, 1.1\}, \{50, 1e10\}, \{70, 1e11\}\};}
\DoxyCodeLine{864         a.insert(b.begin(), b.end(), [\&collisions](\textcolor{keyword}{auto} \&\&, \textcolor{keyword}{auto} \&\&) \{ ++collisions; \});}
\DoxyCodeLine{865         qtt\_CHECK(a == result);}
\DoxyCodeLine{866         qtt\_CHECK(collisions == 0);}
\DoxyCodeLine{867     \}}
\DoxyCodeLine{868     qtt\_SUBCASE(\textcolor{stringliteral}{"{}insert a flat\_map in middle and at the end, no collisions"{}})}
\DoxyCodeLine{869     \{}
\DoxyCodeLine{870         \textcolor{keywordtype}{int} collisions = 0;}
\DoxyCodeLine{871         flat\_map<int, double> b\{\{50, 1e10\}, \{33, 1e12\}, \{70, 1e11\}\};}
\DoxyCodeLine{872         flat\_map<int, double> result\{\{10, 1.4\}, \{20, 1.2\}, \{30, 1.3\}, \{33, 1e12\}, \{40, 1.1\}, \{50, 1e10\}, \{70, 1e11\}\};}
\DoxyCodeLine{873         a.insert(b.begin(), b.end(), [\&collisions](\textcolor{keyword}{auto} \&\&, \textcolor{keyword}{auto} \&\&) \{ ++collisions; \});}
\DoxyCodeLine{874         qtt\_CHECK(a == result);}
\DoxyCodeLine{875         qtt\_CHECK(collisions == 0);}
\DoxyCodeLine{876     \}}
\DoxyCodeLine{877     qtt\_SUBCASE(\textcolor{stringliteral}{"{}insert a flat\_map in middle, no collisions"{}})}
\DoxyCodeLine{878     \{}
\DoxyCodeLine{879         \textcolor{keywordtype}{int} collisions = 0;}
\DoxyCodeLine{880         flat\_map<int, double> b\{\{33, 1e12\}, \{31, 1e12\}\};}
\DoxyCodeLine{881         flat\_map<int, double> result\{\{10, 1.4\}, \{20, 1.2\}, \{31, 1e12\}, \{30, 1.3\}, \{33, 1e12\}, \{40, 1.1\}\};}
\DoxyCodeLine{882         a.insert(b.begin(), b.end(), [\&collisions](\textcolor{keyword}{auto} \&\&, \textcolor{keyword}{auto} \&\&) \{ ++collisions; \});}
\DoxyCodeLine{883         qtt\_CHECK(a == result);}
\DoxyCodeLine{884         qtt\_CHECK(collisions == 0);}
\DoxyCodeLine{885     \}}
\DoxyCodeLine{886     qtt\_SUBCASE(\textcolor{stringliteral}{"{}insert unsorted sequence"{}})}
\DoxyCodeLine{887     \{}
\DoxyCodeLine{888         \textcolor{keywordtype}{int} collisions = 0;}
\DoxyCodeLine{889         std::vector<std::pair<int, double>> b\{\{1, 6e10\},  \{1, 6e10\}, \{10, 6e10\}, \{50, 1e10\}, \{50, 1e10\},}
\DoxyCodeLine{890                                               \{50, 1e10\}, \{30, 1\},   \{33, 1e12\}, \{70, 1e11\}\};}
\DoxyCodeLine{891         flat\_map<int, double> result\{\{10, 1.4\}, \{20, 1.2\}, \{30, 1.3\},  \{33, 1e12\},}
\DoxyCodeLine{892                                      \{40, 1.1\}, \{1, 6e10\}, \{50, 1e10\}, \{70, 1e11\}\};}
\DoxyCodeLine{893         qtt\_REQUIRE(!std::is\_convertible\_v<\textcolor{keyword}{decltype}(b)::iterator, \textcolor{keyword}{decltype}(a)::const\_iterator>);}
\DoxyCodeLine{894         \textcolor{comment}{// fmt::print("{}a pre \{\}\(\backslash\)n"{},a);}}
\DoxyCodeLine{895         a.insert(b.begin(), b.end(), [\&collisions](\textcolor{keyword}{auto} \&\&, \textcolor{keyword}{auto} \&\&) \{ ++collisions; \});}
\DoxyCodeLine{896         qtt\_CHECK(a == result);}
\DoxyCodeLine{897         \textcolor{comment}{// fmt::print("{}a post \{\}\(\backslash\)n"{},a);}}
\DoxyCodeLine{898         \textcolor{comment}{// fmt::print("{}result \{\}\(\backslash\)n"{},result);}}
\DoxyCodeLine{899         qtt\_CHECK(collisions == 5);}
\DoxyCodeLine{900     \}}
\DoxyCodeLine{901     qtt\_SUBCASE(\textcolor{stringliteral}{"{}merge sequences, collision moment test"{}})}
\DoxyCodeLine{902     \{}
\DoxyCodeLine{903         flat\_map<int, double> a\{\{10, 100\}, \{20, 100\}, \{30, 100\}, \{33, 100\}, \{40, 100\}, \{1, 100\}, \{50, 100\}, \{70, 100\}\};}
\DoxyCodeLine{904         flat\_map<int, double> b\{\{10, 20\}, \{20, 20\}, \{30, 20\}, \{33, 20\}, \{40, 20\}, \{1, 20\}, \{50, 20\}, \{70, 20\}\};}
\DoxyCodeLine{905         flat\_map<int, double> result\{\{10, 120\}, \{20, 120\}, \{30, 120\}, \{33, 120\},}
\DoxyCodeLine{906                                      \{40, 120\}, \{1, 120\},  \{50, 120\}, \{70, 120\}\};}
\DoxyCodeLine{907         a.merge(b, [](\textcolor{keyword}{auto} \&\&x, \textcolor{keyword}{auto} \&\&y) \{ x += y; \});}
\DoxyCodeLine{908         qtt\_CHECK(a == result);}
\DoxyCodeLine{909     \}}
\DoxyCodeLine{910 \}}
\DoxyCodeLine{911 qtt\_TEST\_CASE(\textcolor{stringliteral}{"{}accessors"{}})}
\DoxyCodeLine{912 \{}
\DoxyCodeLine{913     flat\_map<int, int> A;}
\DoxyCodeLine{914     A[0] = 5;}
\DoxyCodeLine{915     A[0] = 6;}
\DoxyCodeLine{916     qtt\_SUBCASE(\textcolor{stringliteral}{"{}first access"{}})}
\DoxyCodeLine{917     \{}
\DoxyCodeLine{918         qtt\_REQUIRE\_NOTHROW(A.at(0));}
\DoxyCodeLine{919         qtt\_CHECK(A[0] == 6);}
\DoxyCodeLine{920     \}}
\DoxyCodeLine{921 \}}
\DoxyCodeLine{922 }
\DoxyCodeLine{923 \} \textcolor{comment}{// namespace quantit}}
\DoxyCodeLine{924 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* D7E9786D\_BD4E\_41BF\_A6C5\_4E902E127A7D */}\textcolor{preprocessor}{}}

\end{DoxyCode}
